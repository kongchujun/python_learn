package main

import (
	"bufio"
	"bytes"
	"crypto/hmac"
	"crypto/md5"
	"crypto/sha256"
	"crypto/tls"
	"encoding/base64"
	"encoding/binary"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"math/rand"
	"net"
	"net/http"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"
)

// 设置详细日志
var logger = log.New(os.Stdout, "[PG-PROXY] ", log.LstdFlags|log.Lshortfile)

// SSL请求的特殊标识符
const (
	SSLRequestCode = 80877103
)

// ConnectionConfig 存储 PostgreSQL 连接参数，支持并发安全读写
type ConnectionConfig struct {
	hostname     string
	port         int
	username     string
	password     string
	databaseName string
	mu           sync.RWMutex
}

// ConnParams 用于传递配置数据
type ConnParams struct {
	Hostname, Username, Password, Database string
	Port                                   int
}

// SetConfig 更新连接配置
func (cc *ConnectionConfig) SetConfig(hostname string, port int, username, password, databaseName string) {
	cc.mu.Lock()
	defer cc.mu.Unlock()
	cc.hostname = hostname
	cc.port = port
	cc.username = username
	cc.password = password
	cc.databaseName = databaseName
	logger.Printf("Config updated: %s:%d user=%s db=%s", hostname, port, username, databaseName)
}

// GetConfig 返回当前连接参数
func (cc *ConnectionConfig) GetConfig() ConnParams {
	cc.mu.RLock()
	defer cc.mu.RUnlock()
	return ConnParams{
		Hostname: cc.hostname,
		Port:     cc.port,
		Username: cc.username,
		Password: cc.password,
		Database: cc.databaseName,
	}
}

// Config 定义代理和 API 服务地址及连接池参数
type Config struct {
	ProxyListenAddr       string        // 代理监听地址
	APIListenAddr         string        // API 监听地址
	APIPasswordUpdate     string        // 更新配置 API 路径
	PoolSize              int           // 连接池大小
	ProxyAuthPassword     string        // 代理访问校验密码
	ConnectTimeout        time.Duration // 连接超时
	ConnectionAttempts    int           // 连接尝试次数
	EnableSSL             bool          // 是否启用SSL
	SSLCertPath           string        // SSL证书路径
	SSLKeyPath            string        // SSL密钥路径
	LogProtocol           bool          // 是否记录详细协议交换
	PasswordParamName     string        // 密码参数名称
	AcceptEmptyProxyPwd   bool          // 接受空密码
	BypassProxyPwdCheck   bool          // 跳过密码检查
}

// StartupMessage 表示 PostgreSQL 启动包
type StartupMessage struct {
	ProtocolVersion int32
	Parameters      map[string]string
	Raw             []byte
	IsSSLRequest    bool
}

// ConnPool 后端连接池，支持主动清空机制
type ConnPool struct {
	cc       *ConnectionConfig
	pool     chan net.Conn
	size     int
	draining bool
	mu       sync.Mutex
	cfg      *Config
}

// newPool 创建连接池
func newPool(cc *ConnectionConfig, size int, cfg *Config) *ConnPool {
	return &ConnPool{
		cc:   cc,
		pool: make(chan net.Conn, size),
		size: size,
		cfg:  cfg,
	}
}

// Get 从池中获取连接，池空则新建
func (p *ConnPool) Get() (net.Conn, error) {
	select {
	case conn := <-p.pool:
		// 检查连接是否仍然有效
		conn.SetReadDeadline(time.Now().Add(100 * time.Millisecond))
		one := make([]byte, 1)
		_, err := conn.Read(one)
		conn.SetReadDeadline(time.Time{}) // 重置读取超时

		if err == nil {
			// 连接有数据，不能重用
			logger.Printf("Connection has data, cannot reuse")
			conn.Close()
		} else if err != io.EOF && !os.IsTimeout(err) {
			// 连接出错且不是EOF或超时，不能重用
			logger.Printf("Connection error: %v, cannot reuse", err)
			conn.Close()
		} else {
			// 连接看起来正常，可以重用
			logger.Printf("Reusing connection from pool")
			return conn, nil
		}
	default:
		// 池为空，需要新建
	}

	params := p.cc.GetConfig()
	addr := fmt.Sprintf("%s:%d", params.Hostname, params.Port)
	logger.Printf("Dialing backend at %s", addr)

	// 尝试多次连接
	var conn net.Conn
	var err error

	for i := 0; i < p.cfg.ConnectionAttempts; i++ {
		dialer := net.Dialer{Timeout: p.cfg.ConnectTimeout}
		conn, err = dialer.Dial("tcp", addr)
		if err == nil {
			break
		}
		logger.Printf("Connection attempt %d failed: %v", i+1, err)
		time.Sleep(100 * time.Millisecond) // 短暂延迟后重试
	}

	if err != nil {
		return nil, fmt.Errorf("failed to connect to backend after %d attempts: %w",
			p.cfg.ConnectionAttempts, err)
	}

	logger.Printf("New connection established to %s", addr)
	return conn, nil
}

// Put 将连接归还池中；draining 时关闭
func (p *ConnPool) Put(conn net.Conn) {
	if conn == nil {
		return
	}

	p.mu.Lock()
	defer p.mu.Unlock()

	if p.draining {
		logger.Printf("Pool is draining, closing connection")
		conn.Close()
		return
	}

	// 设置超时以检测连接是否可用
	conn.SetReadDeadline(time.Now().Add(100 * time.Millisecond))
	one := make([]byte, 1)
	_, err := conn.Read(one)
	conn.SetReadDeadline(time.Time{}) // 重置超时

	if err == io.EOF {
		logger.Printf("Connection EOF, may be closed by server")
		conn.Close()
	} else if os.IsTimeout(err) {
		// 超时意味着没有待读数据，连接可能仍然有效
		select {
		case p.pool <- conn:
			logger.Printf("Connection returned to pool")
		default:
			logger.Printf("Pool full, closing connection")
			conn.Close()
		}
	} else {
		// 连接有数据或出错
		logger.Printf("Connection has data or error: %v, closing", err)
		conn.Close()
	}
}

// Reset 主动清空空闲连接，并重建 channel
func (p *ConnPool) Reset() {
	p.mu.Lock()
	defer p.mu.Unlock()

	logger.Printf("Resetting connection pool")
	p.draining = true

	// 关闭所有连接
	close(p.pool)
	count := 0
	for c := range p.pool {
		c.Close()
		count++
	}
	logger.Printf("Closed %d connections from pool", count)

	// 重建池
	p.pool = make(chan net.Conn, p.size)
	p.draining = false
}

var (
	connConfig = &ConnectionConfig{}
	cfg        = Config{
		ProxyListenAddr:      ":5433",
		APIListenAddr:        ":8080",
		APIPasswordUpdate:    "/update-password",
		PoolSize:             10,
		ProxyAuthPassword:    "pwd_postgres",
		ConnectTimeout:       5 * time.Second,
		ConnectionAttempts:   3,
		EnableSSL:            false,    // 默认不启用SSL
		SSLCertPath:          "server.crt",
		SSLKeyPath:           "server.key",
		LogProtocol:          true,     // 默认记录详细协议
		PasswordParamName:    "password", // 默认密码参数名
		AcceptEmptyProxyPwd:  false,    // 默认不接受空密码
		BypassProxyPwdCheck:  false,    // 默认不跳过密码检查
	}
	activePool *ConnPool
	oldPool    *ConnPool
	poolMu     sync.Mutex
)

// SASL/SCRAM相关常量
const (
	clientProof = "p" // SASL client proof attribute
	serverSign  = "v" // SASL server signature attribute
)

// 生成随机字符串，用作client nonce
func randomString(length int) string {
	const charset = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
	seededRand := rand.New(rand.NewSource(time.Now().UnixNano()))
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[seededRand.Intn(len(charset))]
	}
	return string(b)
}

// rotatePools 切换到新池并重置旧池
func rotatePools() {
	poolMu.Lock()
	defer poolMu.Unlock()

	logger.Printf("Rotating connection pools")
	newP := newPool(connConfig, cfg.PoolSize, &cfg)

	if activePool != nil {
		oldPool = activePool
		oldPool.Reset()
	}

	activePool = newP
}

func main() {
	// 配置文件日志
	f, err := os.OpenFile("postgres_proxy.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err == nil {
		multiWriter := io.MultiWriter(os.Stdout, f)
		logger = log.New(multiWriter, "[PG-PROXY] ", log.LstdFlags|log.Lshortfile)
	}

	// 打印启动信息
	logger.Printf("Starting PostgreSQL Proxy")
	logger.Printf("Proxy will listen on: %s", cfg.ProxyListenAddr)
	logger.Printf("API will listen on: %s", cfg.APIListenAddr)
	logger.Printf("Proxy password: %s", cfg.ProxyAuthPassword)
	logger.Printf("Password parameter name: %s", cfg.PasswordParamName)
	logger.Printf("Accept empty proxy pwd: %v", cfg.AcceptEmptyProxyPwd)
	logger.Printf("Bypass proxy pwd check: %v", cfg.BypassProxyPwdCheck)
	
	// 初始化连接配置
	connConfig.SetConfig("postgres", 5432, "postgres", "initial_password", "mydb")
	activePool = newPool(connConfig, cfg.PoolSize, &cfg)

	// 启动API服务器
	go func() {
		if err := startAPIServer(); err != nil {
			logger.Fatalf("API server failed: %v", err)
		}
	}()

	// 启动代理服务器
	if err := startProxyServer(); err != nil {
		logger.Fatalf("Proxy server failed: %v", err)
	}
}

// startAPIServer 提供 HTTP 接口，更新配置并切换池
func startAPIServer() error {
	http.HandleFunc(cfg.APIPasswordUpdate, func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			logger.Printf("Received non-POST request to update endpoint")
			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
			return
		}

		var req struct {
			Hostname     string `json:"hostname"`
			Port         int    `json:"port"`
			Username     string `json:"username"`
			Password     string `json:"password"`
			DatabaseName string `json:"databasename"`
		}

		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			logger.Printf("Failed to parse update request: %v", err)
			http.Error(w, "Bad request: "+err.Error(), http.StatusBadRequest)
			return
		}

		if req.Hostname == "" || req.Port == 0 || req.Username == "" || req.Password == "" || req.DatabaseName == "" {
			logger.Printf("Incomplete update request: %+v", req)
			http.Error(w, "All fields required", http.StatusBadRequest)
			return
		}

		logger.Printf("Updating config with new parameters")
		connConfig.SetConfig(req.Hostname, req.Port, req.Username, req.Password, req.DatabaseName)
		rotatePools()

		w.WriteHeader(http.StatusOK)
		fmt.Fprint(w, "Config updated and pools rotated")
		logger.Printf("Config update successful")
	})

	// 代理密码更新
	http.HandleFunc("/update-proxy-password", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
			return
		}

		var req struct {
			Password string `json:"password"`
		}

		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Bad request: "+err.Error(), http.StatusBadRequest)
			return
		}

		if req.Password == "" && !cfg.AcceptEmptyProxyPwd {
			http.Error(w, "Password required", http.StatusBadRequest)
			return
		}

		cfg.ProxyAuthPassword = req.Password
		w.WriteHeader(http.StatusOK)
		fmt.Fprintf(w, "Proxy password updated")
		logger.Printf("Proxy password updated to: %s", req.Password)
	})

	// 密码认证配置
	http.HandleFunc("/update-auth-config", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
			return
		}

		var req struct {
			PasswordParamName   string `json:"password_param_name"`
			AcceptEmptyProxyPwd bool   `json:"accept_empty_proxy_pwd"`
			BypassProxyPwdCheck bool   `json:"bypass_proxy_pwd_check"`
		}

		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Bad request: "+err.Error(), http.StatusBadRequest)
			return
		}

		if req.PasswordParamName != "" {
			cfg.PasswordParamName = req.PasswordParamName
		}
		cfg.AcceptEmptyProxyPwd = req.AcceptEmptyProxyPwd
		cfg.BypassProxyPwdCheck = req.BypassProxyPwdCheck

		w.WriteHeader(http.StatusOK)
		fmt.Fprintf(w, "Authentication configuration updated")
		logger.Printf("Auth config updated: param=%s, accept_empty=%v, bypass=%v", 
			cfg.PasswordParamName, cfg.AcceptEmptyProxyPwd, cfg.BypassProxyPwdCheck)
	})

	// SSL配置更新
	http.HandleFunc("/update-ssl", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
			return
		}

		var req struct {
			EnableSSL   bool   `json:"enable_ssl"`
			SSLCertPath string `json:"ssl_cert_path,omitempty"`
			SSLKeyPath  string `json:"ssl_key_path,omitempty"`
		}

		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Bad request: "+err.Error(), http.StatusBadRequest)
			return
		}

		cfg.EnableSSL = req.EnableSSL
		if req.SSLCertPath != "" {
			cfg.SSLCertPath = req.SSLCertPath
		}
		if req.SSLKeyPath != "" {
			cfg.SSLKeyPath = req.SSLKeyPath
		}

		w.WriteHeader(http.StatusOK)
		fmt.Fprintf(w, "SSL config updated: enabled=%v", cfg.EnableSSL)
	})

	// 日志级别配置
	http.HandleFunc("/update-logging", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodPost {
			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
			return
		}

		var req struct {
			LogProtocol bool `json:"log_protocol"`
		}

		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Bad request: "+err.Error(), http.StatusBadRequest)
			return
		}

		cfg.LogProtocol = req.LogProtocol
		w.WriteHeader(http.StatusOK)
		fmt.Fprintf(w, "Logging config updated: log_protocol=%v", cfg.LogProtocol)
	})

	// 添加健康检查端点
	http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		fmt.Fprint(w, "OK")
	})

	// 显示当前配置状态（敏感信息隐藏）
	http.HandleFunc("/status", func(w http.ResponseWriter, r *http.Request) {
		params := connConfig.GetConfig()
		status := struct {
			Hostname           string `json:"hostname"`
			Port               int    `json:"port"`
			Username           string `json:"username"`
			Database           string `json:"database"`
			SSLEnabled         bool   `json:"ssl_enabled"`
			LogProtocol        bool   `json:"log_protocol"`
			PasswordParamName  string `json:"password_param_name"`
			ProxyPassword      string `json:"proxy_password"`
			AcceptEmptyProxyPwd bool  `json:"accept_empty_proxy_pwd"`
			BypassProxyPwdCheck bool  `json:"bypass_proxy_pwd_check"`
		}{
			Hostname:          params.Hostname,
			Port:              params.Port,
			Username:          params.Username,
			Database:          params.Database,
			SSLEnabled:        cfg.EnableSSL,
			LogProtocol:       cfg.LogProtocol,
			PasswordParamName: cfg.PasswordParamName,
			ProxyPassword:     cfg.ProxyAuthPassword,
			AcceptEmptyProxyPwd: cfg.AcceptEmptyProxyPwd,
			BypassProxyPwdCheck: cfg.BypassProxyPwdCheck,
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(status)
	})

	// 启动测试端点 - 测试到后端的连接
	http.HandleFunc("/test-connection", func(w http.ResponseWriter, r *http.Request) {
		poolMu.Lock()
		p := activePool
		poolMu.Unlock()

		conn, err := p.Get()
		if err != nil {
			http.Error(w, fmt.Sprintf("Failed to connect to backend: %v", err), http.StatusInternalServerError)
			return
		}
		
		// 这里我们不使用defer p.Put(conn)，而是直接关闭连接
		defer conn.Close()

		// 测试发送一个简单的查询
		params := connConfig.GetConfig()
		
		// 发送启动消息
		sm := &StartupMessage{
			ProtocolVersion: 196608, // 3.0
			Parameters: map[string]string{
				"user":     params.Username,
				"database": params.Database,
			},
		}
		
		startupData, err := serializeStartup(sm)
		if err != nil {
			http.Error(w, fmt.Sprintf("Failed to serialize startup message: %v", err), http.StatusInternalServerError)
			return
		}
		
		if _, err = conn.Write(startupData); err != nil {
			http.Error(w, fmt.Sprintf("Failed to send startup message: %v", err), http.StatusInternalServerError)
			return
		}

		// 读取并处理认证流程，包括SASL认证
		authResult, err := handleTestAuth(conn, params.Username, params.Password)
		if err != nil {
			http.Error(w, fmt.Sprintf("Authentication failed: %v", err), http.StatusInternalServerError)
			return
		}

		fmt.Fprintf(w, "Successfully connected to backend PostgreSQL. Auth result: %s", authResult)
	})

	logger.Printf("API server listening on %s", cfg.APIListenAddr)
	return http.ListenAndServe(cfg.APIListenAddr, nil)
}

// handleTestAuth 处理测试连接的认证流程
func handleTestAuth(conn net.Conn, username, password string) (string, error) {
	buf := make([]byte, 8192)
	
	// 认证循环
	for {
		// 读取服务器消息
		conn.SetReadDeadline(time.Now().Add(10 * time.Second))
		msgType, msgLen, payload, err := readMessage(conn, buf)
		conn.SetReadDeadline(time.Time{})
		
		if err != nil {
			return "", fmt.Errorf("read from server: %w", err)
		}
		
		// 处理特定类型的消息
		if msgType == 'R' {
			// 认证消息
			authType := binary.BigEndian.Uint32(payload[:4])
			
			switch authType {
			case 0:
				// 认证成功
				return "Authentication successful", nil
			case 3:
				// 明文密码认证
				logger.Printf("Test: Server requested cleartext password auth")
				if err := sendPasswordMsg(conn, password); err != nil {
					return "", fmt.Errorf("send password: %w", err)
				}
			case 5:
				// MD5密码认证
				logger.Printf("Test: Server requested MD5 password auth")
				salt := payload[4:8]
				hashedPwd := md5Password(password, username, salt)
				if err := sendPasswordMsg(conn, hashedPwd); err != nil {
					return "", fmt.Errorf("send MD5 password: %w", err)
				}
			case 10:
				// SASL认证
				logger.Printf("Test: Server requested SASL auth")
				
				// 从payload中提取SASL机制
				offset := 4
				nullPos := bytes.IndexByte(payload[offset:], 0)
				if nullPos < 0 {
					return "", fmt.Errorf("malformed SASL auth message")
				}
				mechListStr := string(payload[offset : offset+nullPos])
				mechList := strings.Split(mechListStr, ",")
				logger.Printf("Test: SASL mechanisms: %v", mechList)
				
				// 选择SCRAM-SHA-256机制
				var mechanism string
				for _, mech := range mechList {
					if mech == "SCRAM-SHA-256" {
						mechanism = mech
						break
					}
				}
				
				if mechanism == "" {
					return "", fmt.Errorf("SCRAM-SHA-256 mechanism not available")
				}
				
				// 执行SCRAM-SHA-256认证
				clientNonce := randomString(18)
				
				// 创建客户端首消息
				saslInitialMsg := SaslInitialMsg{
					Mechanism: mechanism,
					Message:   fmt.Sprintf("n,,n=%s,r=%s", username, clientNonce),
				}
				
				initialData, err := saslInitialMsg.Build()
				if err != nil {
					return "", fmt.Errorf("build SASL initial: %w", err)
				}
				
				if err := sendMessage(conn, 'p', initialData); err != nil {
					return "", fmt.Errorf("send SASL initial: %w", err)
				}
				
				// 读取服务器首次响应
				conn.SetReadDeadline(time.Now().Add(10 * time.Second))
				sMsgType, sMsgLen, sPayload, err := readMessage(conn, buf)
				conn.SetReadDeadline(time.Time{})
				
				if err != nil {
					return "", fmt.Errorf("read SASL first server response: %w", err)
				}
				
				if sMsgType == 'E' {
					errMsg := extractErrorMessage(sPayload)
					return "", fmt.Errorf("server error: %s", errMsg)
				}
				
				if sMsgType != 'R' || binary.BigEndian.Uint32(sPayload[:4]) != 11 {
					return "", fmt.Errorf("unexpected server response to SASL initial message")
				}
				
				// 解析服务器挑战
				serverFirstMsg := string(sPayload[4:])
				serverFirstDict := parseSaslAttributes(serverFirstMsg)
				serverNonce := serverFirstDict["r"]
				salt := serverFirstDict["s"]
				iterations := serverFirstDict["i"]
				
				if !strings.HasPrefix(serverNonce, clientNonce) {
					return "", fmt.Errorf("server nonce does not start with client nonce")
				}
				
				// 解码salt
				saltBytes, err := base64.StdEncoding.DecodeString(salt)
				if err != nil {
					return "", fmt.Errorf("decode salt: %w", err)
				}
				
				// 解析迭代次数
				iterCount, err := strconv.Atoi(iterations)
				if err != nil {
					return "", fmt.Errorf("parse iterations: %w", err)
				}
				
				// 计算客户端和服务器证明
				saltedPassword := hi(password, saltBytes, iterCount)
				clientKey := hmacSha256(saltedPassword, []byte("Client Key"))
				storedKey := sha256Sum(clientKey)
				
				// 认证消息
				authMsg := fmt.Sprintf("n=%s,r=%s,%s,c=biws,r=%s", 
					username, clientNonce, serverFirstMsg, serverNonce)
				
				clientSignature := hmacSha256(storedKey, []byte(authMsg))
				clientProofBytes := xorBytes(clientKey, clientSignature)
				clientProofStr := base64.StdEncoding.EncodeToString(clientProofBytes)
				
				// 计算服务器签名
				serverKey := hmacSha256(saltedPassword, []byte("Server Key"))
				serverSignature := hmacSha256(serverKey, []byte(authMsg))
				
				// 构造客户端最终消息
				clientFinalMsg := fmt.Sprintf("c=biws,r=%s,p=%s", 
					serverNonce, clientProofStr)
				
				if err := sendMessage(conn, 'p', []byte(clientFinalMsg)); err != nil {
					return "", fmt.Errorf("send SASL final: %w", err)
				}
				
				// 读取服务器最终响应
				conn.SetReadDeadline(time.Now().Add(10 * time.Second))
				sMsgType, sMsgLen, sPayload, err = readMessage(conn, buf)
				conn.SetReadDeadline(time.Time{})
				
				if err != nil {
					return "", fmt.Errorf("read SASL server final: %w", err)
				}
				
				if sMsgType == 'E' {
					errMsg := extractErrorMessage(sPayload)
					return "", fmt.Errorf("server error: %s", errMsg)
				}
				
				if sMsgType != 'R' || binary.BigEndian.Uint32(sPayload[:4]) != 12 {
					return "", fmt.Errorf("unexpected server response to SASL final message")
				}
				
				// 验证服务器签名
				serverFinalMsg := string(sPayload[4:])
				serverFinalDict := parseSaslAttributes(serverFinalMsg)
				serverSignBase64 := serverFinalDict["v"]
				
				serverSignBytes, err := base64.StdEncoding.DecodeString(serverSignBase64)
				if err != nil {
					return "", fmt.Errorf("decode server signature: %w", err)
				}
				
				if !bytes.Equal(serverSignature, serverSignBytes) {
					return "", fmt.Errorf("server signature verification failed")
				}
				
				// 发送空消息完成SASL
				if err := sendMessage(conn, 'p', []byte{}); err != nil {
					return "", fmt.Errorf("send SASL completion: %w", err)
				}
				
			default:
				return "", fmt.Errorf("unsupported auth type: %d", authType)
			}
		} else if msgType == 'E' {
			// 错误消息
			errMsg := extractErrorMessage(payload)
			return "", fmt.Errorf("server error: %s", errMsg)
		} else if msgType == 'Z' {
			// ReadyForQuery - 认证完成
			return "Authentication complete, server ready", nil
		}
	}
}

// HMAC-SHA256计算
func hmacSha256(key, data []byte) []byte {
	h := hmac.New(sha256.New, key)
	h.Write(data)
	return h.Sum(nil)
}

// SHA256计算
func sha256Sum(data []byte) []byte {
	hash := sha256.Sum256(data)
	return hash[:]
}

// XOR两个字节数组
func xorBytes(a, b []byte) []byte {
	result := make([]byte, len(a))
	for i := 0; i < len(a); i++ {
		result[i] = a[i] ^ b[i]
	}
	return result
}

// hi函数 (PBKDF2)
func hi(password string, salt []byte, iterations int) []byte {
	// 初始值为密码和盐的HMAC
	u := hmacSha256([]byte(password), salt)
	result := make([]byte, len(u))
	copy(result, u)
	
	// 进行指定次数的迭代
	for i := 1; i < iterations; i++ {
		u = hmacSha256([]byte(password), u)
		for j := 0; j < len(u); j++ {
			result[j] ^= u[j]
		}
	}
	
	return result
}

// SaslInitialMsg SASL初始消息结构
type SaslInitialMsg struct {
	Mechanism string
	Message   string
}

// Build 构造SASL初始消息
func (s *SaslInitialMsg) Build() ([]byte, error) {
	var buf bytes.Buffer
	
	// 机制名称
	buf.WriteString(s.Mechanism)
	buf.WriteByte(0)
	
	// 消息长度
	msgLen := len(s.Message)
	lenBytes := make([]byte, 4)
	binary.BigEndian.PutUint32(lenBytes, uint32(msgLen))
	buf.Write(lenBytes)
	
	// 消息内容
	buf.WriteString(s.Message)
	
	return buf.Bytes(), nil
}

// 解析SASL属性字符串
func parseSaslAttributes(s string) map[string]string {
	result := make(map[string]string)
	parts := strings.Split(s, ",")
	
	for _, part := range parts {
		if len(part) < 2 || !strings.Contains(part, "=") {
			continue
		}
		
		kv := strings.SplitN(part, "=", 2)
		if len(kv) == 2 {
			result[kv[0]] = kv[1]
		}
	}
	
	return result
}

// 提取PostgreSQL错误消息
func extractErrorMessage(payload []byte) string {
	var errMsg string
	for i := 0; i < len(payload); {
		fieldType := payload[i]
		if fieldType == 0 {
			break
		}
		i++
		end := bytes.IndexByte(payload[i:], 0)
		if end < 0 {
			break
		}
		value := string(payload[i : i+end])
		i += end + 1
		if fieldType == 'M' {
			errMsg = value
		}
	}
	return errMsg
}

// startProxyServer 启动 TCP 代理
func startProxyServer() error {
	ln, err := net.Listen("tcp", cfg.ProxyListenAddr)
	if err != nil {
		return fmt.Errorf("proxy listen failed: %w", err)
	}

	logger.Printf("Proxy server listening on %s", cfg.ProxyListenAddr)

	for {
		clientConn, err := ln.Accept()
		if err != nil {
			logger.Printf("Accept error: %v", err)
			continue
		}

		clientAddr := clientConn.RemoteAddr()
		logger.Printf("New client connection from %s", clientAddr)

		go handleClient(clientConn)
	}
}

// 记录协议交换
func logProtocol(direction, msgType string, msgLen int, payload []byte) {
	if !cfg.LogProtocol {
		return
	}
	
	// 根据消息类型提取有用信息
	var details string
	if len(payload) >= 4 && (msgType == "R" || msgType == "r") {
		authType := binary.BigEndian.Uint32(payload[:4])
		switch authType {
		case 0:
			details = "Authentication OK"
		case 2:
			details = "Kerberos V5"
		case 3:
			details = "CleartextPassword"
		case 5:
			details = "MD5Password"
		case 6:
			details = "SCMCredential"
		case 7:
			details = "GSS"
		case 8:
			details = "GSSContinue"
		case 9:
			details = "SSPI"
		case 10:
			details = "SASL"
		case 11:
			details = "SASLContinue"
		case 12:
			details = "SASLComplete"
		}
	} else if msgType == "p" {
		details = "PasswordMessage"
	} else if msgType == "E" {
		details = "ErrorResponse: " + extractErrorMessage(payload)
	}
	
	logger.Printf("%s: type=%s len=%d details=%s", direction, msgType, msgLen, details)
}

// handleClient 处理客户端连接：Startup/Auth 转发
func handleClient(clientConn net.Conn) {
	clientAddr := clientConn.RemoteAddr()
	logger.Printf("Handling client connection from %s", clientAddr)

	defer func() {
		clientConn.Close()
		logger.Printf("Client connection from %s closed", clientAddr)
	}()

	clientBuf := bufio.NewReader(clientConn)

	// 读取客户端的startup消息
	logger.Printf("Reading startup message from client %s", clientAddr)
	skb, err := readStartupMessage(clientBuf)
	if err != nil {
		logger.Printf("Failed to read startup message from client %s: %v", clientAddr, err)
		return
	}

	// 处理SSL请求
	if skb.IsSSLRequest {
		handleSSLRequest(clientConn, clientBuf)
		return
	}

	// 获取客户端提供的参数
	logger.Printf("Client %s startup parameters: %v", clientAddr, skb.Parameters)

	// 查找所有可能的密码参数名称
	proxyPwd := ""
	possiblePwdParams := []string{cfg.PasswordParamName, "password", "pass", "pwd"}
	for _, paramName := range possiblePwdParams {
		if pwd, ok := skb.Parameters[paramName]; ok && pwd != "" {
			logger.Printf("Found password in parameter '%s': %s", paramName, pwd)
			proxyPwd = pwd
			delete(skb.Parameters, paramName)
		}
	}
	
	// 密码验证逻辑
	if !cfg.BypassProxyPwdCheck {
		if proxyPwd == "" && !cfg.AcceptEmptyProxyPwd {
			logger.Printf("Empty proxy password from client %s not allowed", clientAddr)
			sendErrorToClient(clientConn, "Proxy authentication password required")
			return
		}
		
		if proxyPwd != cfg.ProxyAuthPassword {
			logger.Printf("Invalid proxy password from client %s. Got '%s', expected '%s'", 
				clientAddr, proxyPwd, cfg.ProxyAuthPassword)
			sendErrorToClient(clientConn, "Invalid proxy authentication password")
			return
		}
		logger.Printf("Proxy authentication successful for client %s", clientAddr)
	} else {
		logger.Printf("Bypassing proxy password check for client %s", clientAddr)
	}

	// 获取后端连接
	poolMu.Lock()
	p := activePool
	poolMu.Unlock()

	logger.Printf("Acquiring backend connection for client %s", clientAddr)
	serverConn, err := p.Get()
	if err != nil {
		logger.Printf("Failed to get backend connection for client %s: %v", clientAddr, err)
		sendErrorToClient(clientConn, "Backend connection failed: "+err.Error())
		return
	}

	serverAddr := serverConn.RemoteAddr()
	logger.Printf("Got backend connection to %s for client %s", serverAddr, clientAddr)

	defer func() {
		logger.Printf("Closing backend connection to %s", serverAddr)
		serverConn.Close() // 直接关闭，不重用
	}()

	// 用后端真实的用户名和数据库替换客户端提供的
	params := connConfig.GetConfig()
	skb.Parameters["user"] = params.Username
	skb.Parameters["database"] = params.Database

	logger.Printf("Modified startup parameters for client %s: %v", clientAddr, skb.Parameters)

	// 序列化并发送到后端
	logger.Printf("Serializing and sending startup message to backend %s", serverAddr)
	data, err := serializeStartup(skb)
	if err != nil {
		logger.Printf("Failed to serialize startup message for client %s: %v", clientAddr, err)
		sendErrorToClient(clientConn, "Failed to prepare startup message")
		return
	}

	// 添加详细诊断
	logger.Printf("Sending %d bytes of startup data to backend %s", len(data), serverAddr)
	_, err = serverConn.Write(data)
	if err != nil {
		logger.Printf("Failed to send startup message to server %s: %v", serverAddr, err)
		sendErrorToClient(clientConn, "Failed to connect to backend: "+err.Error())
		return
	}

	// 使用完整的认证转发模式
	logger.Printf("Starting authentication for client %s", clientAddr)
	if err := handleFullAuth(serverConn, clientConn, params.Password); err != nil {
		logger.Printf("Authentication error for client %s: %v", clientAddr, err)
		sendErrorToClient(clientConn, "Authentication failed: "+err.Error())
		return
	}

	logger.Printf("Authentication successful for client %s, entering relay mode", clientAddr)

	// 正向和反向复制数据
	errCh := make(chan error, 2)
	doneCh := make(chan struct{})

	// 客户端 -> 服务器
	go func() {
		defer close(doneCh)
		buf := make([]byte, 32*1024)
		for {
			n, err := clientConn.Read(buf)
			if err != nil {
				if err != io.EOF {
					logger.Printf("Error reading from client %s: %v", clientAddr, err)
				}
				errCh <- err
				return
			}

			if n > 0 {
				// 记录客户端发送的命令类型
				if cfg.LogProtocol && n > 0 {
					msgType := string(buf[0])
					msgLen := int(binary.BigEndian.Uint32(buf[1:5]))
					if msgLen > 4 && n >= 5 {
						logProtocol("Client->Server", msgType, msgLen, buf[5:min(n, msgLen+1)])
					}
				}

				_, err = serverConn.Write(buf[:n])
				if err != nil {
					logger.Printf("Error writing to server %s: %v", serverAddr, err)
					errCh <- err
					return
				}
			}
		}
	}()

	// 服务器 -> 客户端
	go func() {
		buf := make([]byte, 32*1024)
		for {
			select {
			case <-doneCh:
				return
			default:
				n, err := serverConn.Read(buf)
				if err != nil {
					if err != io.EOF {
						logger.Printf("Error reading from server %s: %v", serverAddr, err)
					}
					errCh <- err
					return
				}

				if n > 0 {
					// 记录服务器发送的响应类型
					if cfg.LogProtocol && n > 0 {
						msgType := string(buf[0])
						msgLen := int(binary.BigEndian.Uint32(buf[1:5]))
						if msgLen > 4 && n >= 5 {
							logProtocol("Server->Client", msgType, msgLen, buf[5:min(n, msgLen+1)])
						}
					}

					_, err = clientConn.Write(buf[:n])
					if err != nil {
						logger.Printf("Error writing to client %s: %v", clientAddr, err)
						errCh <- err
						return
					}
				}
			}
		}
	}()

	// 等待其中一个数据通道结束
	err = <-errCh
	if err != nil && err != io.EOF {
		logger.Printf("Data relay error for client %s: %v", clientAddr, err)
	} else {
		logger.Printf("Connection closed normally for client %s", clientAddr)
	}
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// handleFullAuth 完整的认证转发处理
func handleFullAuth(serverConn, clientConn net.Conn, realPassword string) error {
	clientAddr := clientConn.RemoteAddr()
	serverAddr := serverConn.RemoteAddr()
	
	// 缓冲区
	serverBuf := make([]byte, 8192)
	clientBuf := make([]byte, 8192)
	
	// 认证循环
	for {
		// 读取服务器消息
		serverConn.SetReadDeadline(time.Now().Add(30 * time.Second))
		msgType, msgLen, payload, err := readMessage(serverConn, serverBuf)
		serverConn.SetReadDeadline(time.Time{})
		
		if err != nil {
			return fmt.Errorf("read from server: %w", err)
		}
		
		// 记录消息类型
		logProtocol("Server->Client", string(msgType), int(msgLen), payload)
		
		// 处理特定类型的消息
		if msgType == 'R' {
			// 这是认证消息
			authType := binary.BigEndian.Uint32(payload[:4])
			
			if authType == 0 {
				// 认证成功
				logger.Printf("Authentication successful")
				// 直接转发给客户端
				if err := forwardMessage(clientConn, msgType, msgLen, payload); err != nil {
					return fmt.Errorf("forward auth success: %w", err)
				}
				continue // 继续处理其他消息
			} else if authType == 3 {
				// 明文密码认证
				logger.Printf("Server requested cleartext password auth")
				// 发送认证请求给客户端
				if err := forwardMessage(clientConn, msgType, msgLen, payload); err != nil {
					return fmt.Errorf("forward auth request: %w", err)
				}
				
				// 从客户端读取密码响应（但我们不会使用它）
				clientConn.SetReadDeadline(time.Now().Add(30 * time.Second))
				cMsgType, cMsgLen, cPayload, err := readMessage(clientConn, clientBuf)
				clientConn.SetReadDeadline(time.Time{})
				
				if err != nil {
					return fmt.Errorf("read client password: %w", err)
				}
				
				logProtocol("Client->Server", string(cMsgType), int(cMsgLen), cPayload)
				
				if cMsgType != 'p' {
					return fmt.Errorf("expected password message, got %c", cMsgType)
				}
				
				// 发送真实密码给服务器
				logger.Printf("Sending real password to server")
				if err := sendPasswordMsg(serverConn, realPassword); err != nil {
					return fmt.Errorf("send password to server: %w", err)
				}
			} else if authType == 5 {
				// MD5密码认证
				logger.Printf("Server requested MD5 password auth")
				salt := payload[4:8]
				
				// 发送认证请求给客户端
				if err := forwardMessage(clientConn, msgType, msgLen, payload); err != nil {
					return fmt.Errorf("forward auth request: %w", err)
				}
				
				// 从客户端读取密码响应（但我们不会使用它）
				clientConn.SetReadDeadline(time.Now().Add(30 * time.Second))
				cMsgType, cMsgLen, cPayload, err := readMessage(clientConn, clientBuf)
				clientConn.SetReadDeadline(time.Time{})
				
				if err != nil {
					return fmt.Errorf("read client password: %w", err)
				}
				
				logProtocol("Client->Server", string(cMsgType), int(cMsgLen), cPayload)
				
				if cMsgType != 'p' {
					return fmt.Errorf("expected password message, got %c", cMsgType)
				}
				
				// 发送MD5哈希密码给服务器
				params := connConfig.GetConfig()
				hashedPwd := md5Password(realPassword, params.Username, salt)
				logger.Printf("Sending MD5 password to server")
				if err := sendPasswordMsg(serverConn, hashedPwd); err != nil {
					return fmt.Errorf("send MD5 password to server: %w", err)
				}
			} else if authType == 10 {
				// SASL认证
				logger.Printf("Server requested SASL auth")
				
				// 从payload中提取SASL机制
				// 跳过auth类型(4字节)
				offset := 4
				nullPos := bytes.IndexByte(payload[offset:], 0)
				if nullPos < 0 {
					return fmt.Errorf("malformed SASL auth message")
				}
				mechListStr := string(payload[offset : offset+nullPos])
				mechList := strings.Split(mechListStr, ",")
				logger.Printf("SASL mechanisms: %v", mechList)
				
				// 转发SASL请求给客户端
				if err := forwardMessage(clientConn, msgType, msgLen, payload); err != nil {
					return fmt.Errorf("forward SASL request: %w", err)
				}
				
				// 从客户端读取SASL初始响应
				clientConn.SetReadDeadline(time.Now().Add(30 * time.Second))
				cMsgType, cMsgLen, cPayload, err := readMessage(clientConn, clientBuf)
				clientConn.SetReadDeadline(time.Time{})
				
				if err != nil {
					return fmt.Errorf("read SASL initial response: %w", err)
				}
				
				logProtocol("Client->Server", string(cMsgType), int(cMsgLen), cPayload)
				
				if cMsgType != 'p' {
					return fmt.Errorf("expected SASL response, got %c", cMsgType)
				}

				// 找出客户端选择的机制
				nullPos = bytes.IndexByte(cPayload, 0)
				if nullPos < 0 {
					return fmt.Errorf("malformed SASL response")
				}
				mechanism := string(cPayload[:nullPos])
				logger.Printf("Client selected SASL mechanism: %s", mechanism)
				
				// 创建自己的SASL消息，使用服务器的真实凭据
				params := connConfig.GetConfig()
				clientNonce := randomString(18)
				
				// 创建客户端首消息
				saslInitialMsg := SaslInitialMsg{
					Mechanism: mechanism,
					Message:   fmt.Sprintf("n,,n=%s,r=%s", params.Username, clientNonce),
				}
				
				initialData, err := saslInitialMsg.Build()
				if err != nil {
					return fmt.Errorf("build SASL response: %w", err)
				}
				
				// 发送自己的SASL初始响应
				if err := sendMessage(serverConn, 'p', initialData); err != nil {
					return fmt.Errorf("send SASL response: %w", err)
				}
				
				// 处理SASL交换
				for {
					// 从服务器读取
					serverConn.SetReadDeadline(time.Now().Add(30 * time.Second))
					sMsgType, sMsgLen, sPayload, err := readMessage(serverConn, serverBuf)
					serverConn.SetReadDeadline(time.Time{})
					
					if err != nil {
						return fmt.Errorf("read SASL challenge: %w", err)
					}
					
					logProtocol("Server->Client", string(sMsgType), int(sMsgLen), sPayload)
					
					// 转发给客户端
					if err := forwardMessage(clientConn, sMsgType, sMsgLen, sPayload); err != nil {
						return fmt.Errorf("forward SASL message: %w", err)
					}
					
					// 解析服务器响应
					if sMsgType == 'R' {
						authRespType := binary.BigEndian.Uint32(sPayload[:4])
						
						if authRespType == 0 {
							// 认证成功
							logger.Printf("SASL authentication successful")
							break // 跳出SASL交换循环
						} else if authRespType == 11 {
							// SASL继续
							// 读取客户端应答
							clientConn.SetReadDeadline(time.Now().Add(30 * time.Second))
							cMsgType, cMsgLen, cPayload, err = readMessage(clientConn, clientBuf)
							clientConn.SetReadDeadline(time.Time{})
							
							if err != nil {
								return fmt.Errorf("read client SASL response: %w", err)
							}
							
							logProtocol("Client->Server", string(cMsgType), int(cMsgLen), cPayload)
							
							// SASL继续消息解析
							serverFirstMsg := string(sPayload[4:])
							serverFirstDict := parseSaslAttributes(serverFirstMsg)
							
							// 提取必要的参数
							serverNonce := serverFirstDict["r"]
							salt := serverFirstDict["s"]
							iterations, _ := strconv.Atoi(serverFirstDict["i"])
							
							// 对服务器处理
							// 解码salt
							saltBytes, err := base64.StdEncoding.DecodeString(salt)
							if err != nil {
								return fmt.Errorf("decode salt: %w", err)
							}
							
							// 计算客户端证明
							saltedPassword := hi(realPassword, saltBytes, iterations)
							clientKey := hmacSha256(saltedPassword, []byte("Client Key"))
							storedKey := sha256Sum(clientKey)
							
							// 构造认证消息
							authMsg := fmt.Sprintf("n=%s,r=%s,%s,c=biws,r=%s",
								params.Username, clientNonce, serverFirstMsg, serverNonce)
							
							clientSignature := hmacSha256(storedKey, []byte(authMsg))
							clientProofBytes := xorBytes(clientKey, clientSignature)
							clientProofStr := base64.StdEncoding.EncodeToString(clientProofBytes)
							
							// 构造客户端最终消息
							clientFinalMsg := fmt.Sprintf("c=biws,r=%s,p=%s",
								serverNonce, clientProofStr)
							
							// 发送给服务器
							if err := sendMessage(serverConn, cMsgType, []byte(clientFinalMsg)); err != nil {
								return fmt.Errorf("send SASL continue: %w", err)
							}
						} else if authRespType == 12 {
							// SASL完成
							clientConn.SetReadDeadline(time.Now().Add(30 * time.Second))
							cMsgType, cMsgLen, cPayload, err = readMessage(clientConn, clientBuf)
							clientConn.SetReadDeadline(time.Time{})
							
							if err != nil {
								return fmt.Errorf("read final SASL response: %w", err)
							}
							
							logProtocol("Client->Server", string(cMsgType), int(cMsgLen), cPayload)
							
							// 转发给服务器
							if err := sendMessage(serverConn, cMsgType, []byte{}); err != nil {
								return fmt.Errorf("forward final SASL: %w", err)
							}
						}
					} else if sMsgType == 'E' {
						// 错误消息
						errMsg := extractErrorMessage(sPayload)
						logger.Printf("SASL error: %s", errMsg)
						return fmt.Errorf("SASL error: %s", errMsg)
					} else if sMsgType == 'Z' {
						// ReadyForQuery - 认证完成
						logger.Printf("SASL completed, server ready")
						return nil
					}
				}
			} else {
				// 其他认证类型
				logger.Printf("Unsupported auth type: %d", authType)
				// 转发给客户端
				if err := forwardMessage(clientConn, msgType, msgLen, payload); err != nil {
					return fmt.Errorf("forward auth message: %w", err)
				}
			}
		} else if msgType == 'E' {
			// 错误消息
			errMsg := extractErrorMessage(payload)
			logger.Printf("Server error: %s", errMsg)
			// 转发给客户端
			if err := forwardMessage(clientConn, msgType, msgLen, payload); err != nil {
				return fmt.Errorf("forward error: %w", err)
			}
			return fmt.Errorf("server error: %s", errMsg)
		} else if msgType == 'Z' {
			// ReadyForQuery - 认证完成
			logger.Printf("Authentication complete, server ready")
			// 转发给客户端
			if err := forwardMessage(clientConn, msgType, msgLen, payload); err != nil {
				return fmt.Errorf("forward ready: %w", err)
			}
			return nil
		} else {
			// 其他消息, 直接转发
			if err := forwardMessage(clientConn, msgType, msgLen, payload); err != nil {
				return fmt.Errorf("forward message: %w", err)
			}
		}
	}
}

// handleSSLRequest 处理SSL连接请求
func handleSSLRequest(clientConn net.Conn, reader *bufio.Reader) {
	clientAddr := clientConn.RemoteAddr()
	logger.Printf("Client %s requested SSL connection", clientAddr)

	if cfg.EnableSSL {
		// 告诉客户端我们支持SSL
		_, err := clientConn.Write([]byte{'S'})
		if err != nil {
			logger.Printf("Failed to send SSL accept to client %s: %v", clientAddr, err)
			return
		}

		// 加载证书
		cert, err := tls.LoadX509KeyPair(cfg.SSLCertPath, cfg.SSLKeyPath)
		if err != nil {
			logger.Printf("Failed to load SSL certificates: %v", err)
			clientConn.Close()
			return
		}

		// 配置TLS
		tlsConfig := &tls.Config{
			Certificates: []tls.Certificate{cert},
			MinVersion:   tls.VersionTLS12,
		}

		// 升级连接为TLS
		tlsConn := tls.Server(clientConn, tlsConfig)
		err = tlsConn.Handshake()
		if err != nil {
			logger.Printf("TLS handshake failed with client %s: %v", clientAddr, err)
			clientConn.Close()
			return
		}

		logger.Printf("TLS handshake successful with client %s", clientAddr)

		// 递归调用，处理升级后的连接
		handleClient(tlsConn)
	} else {
		// 告诉客户端我们不支持SSL
		_, err := clientConn.Write([]byte{'N'})
		if err != nil {
			logger.Printf("Failed to send SSL reject to client %s: %v", clientAddr, err)
			return
		}

		// 客户端应该会继续发送普通StartupMessage
		handleClient(clientConn)
	}
}

// 发送错误消息到客户端
func sendErrorToClient(clientConn net.Conn, message string) {
	// PostgreSQL 错误响应格式
	buf := new(bytes.Buffer)
	buf.WriteByte('E') // 错误消息

	// 占位符，稍后填充长度
	buf.Write([]byte{0, 0, 0, 0})

	// 错误字段
	buf.WriteByte('S') // Severity
	buf.WriteString("FATAL")
	buf.WriteByte(0)

	buf.WriteByte('C') // Code
	buf.WriteString("28000") // 无效的授权规范
	buf.WriteByte(0)

	buf.WriteByte('M') // Message
	buf.WriteString(message)
	buf.WriteByte(0)

	buf.WriteByte(0) // 终止符

	// 计算并填充消息长度
	data := buf.Bytes()
	binary.BigEndian.PutUint32(data[1:5], uint32(buf.Len()-1))

	// 发送错误消息
	_, err := clientConn.Write(data)
	if err != nil {
		logger.Printf("Failed to send error to client: %v", err)
	}
	
	// 发送ReadyForQuery消息，表示可以接受新查询
	readyData := []byte{'Z', 0, 0, 0, 5, 'I'}
	_, err = clientConn.Write(readyData)
	if err != nil {
		logger.Printf("Failed to send ReadyForQuery: %v", err)
	}
}

// forwardMessage 转发消息
func forwardMessage(conn net.Conn, msgType byte, msgLen uint32, payload []byte) error {
	// 构造消息头
	header := make([]byte, 5)
	header[0] = msgType
	binary.BigEndian.PutUint32(header[1:], msgLen)

	// 发送头部
	if _, err := conn.Write(header); err != nil {
		return fmt.Errorf("write message header: %w", err)
	}

	// 发送数据
	if len(payload) > 0 && msgLen > 4 {
		if _, err := conn.Write(payload[:msgLen-4]); err != nil {
			return fmt.Errorf("write message payload: %w", err)
		}
	}

	return nil
}

// sendMessage 发送消息
func sendMessage(conn net.Conn, msgType byte, data []byte) error {
	msgLen := uint32(len(data) + 4)
	header := make([]byte, 5)
	header[0] = msgType
	binary.BigEndian.PutUint32(header[1:], msgLen)

	// 发送头部
	if _, err := conn.Write(header); err != nil {
		return fmt.Errorf("write message header: %w", err)
	}

	// 发送数据
	if len(data) > 0 {
		if _, err := conn.Write(data); err != nil {
			return fmt.Errorf("write message data: %w", err)
		}
	}

	return nil
}

// readMessage 读取一个完整的PostgreSQL消息
func readMessage(conn net.Conn, buf []byte) (byte, uint32, []byte, error) {
	// 读取消息类型
	msgType := make([]byte, 1)
	if _, err := io.ReadFull(conn, msgType); err != nil {
		return 0, 0, nil, fmt.Errorf("read message type: %w", err)
	}

	// 读取消息长度
	lenBuf := make([]byte, 4)
	if _, err := io.ReadFull(conn, lenBuf); err != nil {
		return 0, 0, nil, fmt.Errorf("read message length: %w", err)
	}

	length := binary.BigEndian.Uint32(lenBuf)
	if length < 4 {
		return 0, 0, nil, fmt.Errorf("invalid message length: %d", length)
	}

	// 读取消息内容
	payloadLen := length - 4
	if uint32(cap(buf)) < payloadLen {
		buf = make([]byte, payloadLen)
	}
	payload := buf[:payloadLen]

	if _, err := io.ReadFull(conn, payload); err != nil {
		return 0, 0, nil, fmt.Errorf("read message payload: %w", err)
	}

	return msgType[0], length, payload, nil
}

// sendPasswordMsg 构造并发送 PasswordMessage
func sendPasswordMsg(conn net.Conn, pwd string) error {
	logger.Printf("Building password message: '%s'", pwd)
	data := []byte(pwd)
	length := int32(len(data) + 5) // 包括终止符
	buf := new(bytes.Buffer)
	buf.WriteByte('p')
	binary.Write(buf, binary.BigEndian, length)
	buf.Write(data)
	buf.WriteByte(0) // 终止符

	logger.Printf("Sending %d bytes password message", buf.Len())
	_, err := conn.Write(buf.Bytes())
	if err != nil {
		return fmt.Errorf("write password message: %w", err)
	}
	return nil
}

// readStartupMessage 解析 StartupMessage，支持SSL请求
func readStartupMessage(r *bufio.Reader) (*StartupMessage, error) {
	// 读取消息长度
	lenBuf := make([]byte, 4)
	if _, err := io.ReadFull(r, lenBuf); err != nil {
		return nil, fmt.Errorf("read startup message length: %w", err)
	}

	length := int(binary.BigEndian.Uint32(lenBuf))
	logger.Printf("Startup message length: %d bytes", length)

	if length < 4 || length > 10000 {
		return nil, fmt.Errorf("invalid startup message length: %d", length)
	}

	// 读取版本号/请求代码
	verBuf := make([]byte, 4)
	if _, err := io.ReadFull(r, verBuf); err != nil {
		return nil, fmt.Errorf("read protocol version: %w", err)
	}

	version := int32(binary.BigEndian.Uint32(verBuf))
	logger.Printf("Protocol version: %d", version)

	// 检查是否是SSL请求
	if version == SSLRequestCode {
		// 这是SSL请求，不需要读取更多数据
		logger.Printf("Detected SSL request")
		return &StartupMessage{
			ProtocolVersion: version,
			Parameters:      make(map[string]string),
			Raw:             append(lenBuf, verBuf...),
			IsSSLRequest:    true,
		}, nil
	}

	// 不是SSL请求，处理常规StartupMessage
	paramLen := length - 8
	body := make([]byte, paramLen)
	if _, err := io.ReadFull(r, body); err != nil {
		return nil, fmt.Errorf("read startup message body: %w", err)
	}

	// 解析参数
	params, err := parseParameters(body)
	if err != nil {
		return nil, fmt.Errorf("parse parameters: %w", err)
	}

	// 构建完整消息
	raw := make([]byte, length)
	copy(raw[0:], lenBuf)
	copy(raw[4:], verBuf)
	copy(raw[8:], body)

	logger.Printf("Parsed %d startup parameters", len(params))
	return &StartupMessage{ProtocolVersion: version, Parameters: params, Raw: raw, IsSSLRequest: false}, nil
}

// parseParameters 解析 key=value 列表
func parseParameters(data []byte) (map[string]string, error) {
	m := make(map[string]string)
	i := 0

	for i < len(data) {
		// 找键的结束位置
		j := bytes.IndexByte(data[i:], 0)
		if j < 0 {
			return m, fmt.Errorf("malformed parameter format at offset %d", i)
		}

		if j == 0 {
			// 参数列表结束
			break
		}

		key := string(data[i : i+j])
		i += j + 1

		// 找值的结束位置
		k := bytes.IndexByte(data[i:], 0)
		if k < 0 {
			return m, fmt.Errorf("malformed parameter value for key '%s' at offset %d", key, i)
		}

		val := string(data[i : i+k])
		i += k + 1

		logger.Printf("Parameter: %s = %s", key, val)
		m[key] = val
	}

	return m, nil
}

// serializeStartup 重建 StartupMessage
func serializeStartup(msg *StartupMessage) ([]byte, error) {
	var buf bytes.Buffer

	// 占位符，后面再填充长度
	buf.Write([]byte{0, 0, 0, 0})

	// 写入协议版本
	binary.Write(&buf, binary.BigEndian, uint32(msg.ProtocolVersion))

	// 写入参数
	for k, v := range msg.Parameters {
		buf.WriteString(k)
		buf.WriteByte(0)
		buf.WriteString(v)
		buf.WriteByte(0)
		logger.Printf("Serializing parameter: %s = %s", k, v)
	}

	// 参数列表结束
	buf.WriteByte(0)

	// 填充消息长度
	data := buf.Bytes()
	binary.BigEndian.PutUint32(data[0:4], uint32(buf.Len()))
	logger.Printf("Serialized startup message: %d bytes", buf.Len())

	return data, nil
}

// md5Password 生成 PostgreSQL MD5 密码散列
func md5Password(password, user string, salt []byte) string {
	h1 := md5.New()
	h1.Write([]byte(password + user))
	sum1 := h1.Sum(nil)

	h2 := md5.New()
	h2.Write(sum1)
	h2.Write(salt)

	return "md5" + hex.EncodeToString(h2.Sum(nil))
}
