package main

import (
    "bufio"
    "bytes"
    "crypto/md5"
    "crypto/tls"
    "encoding/binary"
    "encoding/hex"
    "encoding/json"
    "fmt"
    "io"
    "log"
    "net"
    "net/http"
    "sync"
)

// ConnectionConfig 存储 PostgreSQL 连接参数，支持并发安全读写
type ConnectionConfig struct {
    hostname     string
    port         int
    username     string
    password     string
    databaseName string
    mu           sync.RWMutex
}

// SetConfig 更新连接参数
type ConnParams struct {
    Hostname, Username, Password, Database string
    Port                                    int
}

func (cc *ConnectionConfig) SetConfig(hostname string, port int, username, password, databaseName string) {
    cc.mu.Lock()
    defer cc.mu.Unlock()
    cc.hostname = hostname
    cc.port = port
    cc.username = username
    cc.password = password
    cc.databaseName = databaseName
    log.Printf("Connection config updated: %s:%d user=%s db=%s", hostname, port, username, databaseName)
}

// GetConfig 返回当前连接配置
func (cc *ConnectionConfig) GetConfig() ConnParams {
    cc.mu.RLock()
    defer cc.mu.RUnlock()
    return ConnParams{Hostname: cc.hostname, Port: cc.port, Username: cc.username, Password: cc.password, Database: cc.databaseName}
}

// Config 定义代理与 API 服务地址及连接池大小
type Config struct {
    ProxyListenAddr   string // 代理监听地址
    APIListenAddr     string // API 监听地址
    APIPasswordUpdate string // 更新参数 API 路径
    PoolSize          int    // 连接池大小
}

// StartupMessage 解析后的启动消息，用于修改用户/数据库参数
type StartupMessage struct {
    ProtocolVersion int32
    Parameters      map[string]string
    Raw             []byte
}

// ConnPool 封装后端连接池，基于 channel 实现，支持主动 reset
type ConnPool struct {
    cc       *ConnectionConfig
    pool     chan net.Conn
    size     int
    draining bool
    mu       sync.Mutex
}

// newPool 创建指定大小的连接池
func newPool(cc *ConnectionConfig, size int) *ConnPool {
    return &ConnPool{cc: cc, pool: make(chan net.Conn, size), size: size}
}

// Get 从池中获取连接，池空时新建
func (p *ConnPool) Get() (net.Conn, error) {
    select {
    case conn := <-p.pool:
        return conn, nil
    default:
        params := p.cc.GetConfig()
        return net.Dial("tcp", fmt.Sprintf("%s:%d", params.Hostname, params.Port))
    }
}

// Put 将连接归还池中，如在 draining 状态则关闭，多余则关闭
func (p *ConnPool) Put(conn net.Conn) {
    p.mu.Lock()
    defer p.mu.Unlock()
    if p.draining {
        conn.Close()
        return
    }
    select {
    case p.pool <- conn:
    default:
        conn.Close()
    }
}

// Reset 主动关闭并清空池中所有空闲连接，标记 draining
func (p *ConnPool) Reset() {
    p.mu.Lock()
    p.draining = true
    close(p.pool)
    for conn := range p.pool {
        conn.Close()
    }
    p.pool = make(chan net.Conn, p.size)
    p.draining = false
    p.mu.Unlock()
}

// 全局变量：双池策略
var (
    activePool *ConnPool
    oldPool    *ConnPool
    poolMu     sync.Mutex
    cfg        = Config{ProxyListenAddr: ":5433", APIListenAddr: ":8080", APIPasswordUpdate: "/update-password", PoolSize: 10}
    connConfig = &ConnectionConfig{}
)

// rotatePools 切换到新池，并 reset 旧池，避免连接泄漏
func rotatePools() {
    poolMu.Lock()
    defer poolMu.Unlock()
    newPool := newPool(connConfig, cfg.PoolSize)
    if activePool != nil {
        oldPool = activePool
        oldPool.Reset()
    }
    activePool = newPool
}

func main() {
    // 初始配置
    connConfig.SetConfig("postgres", 5432, "postgres", "initial_password", "mydb")
    activePool = newPool(connConfig, cfg.PoolSize)

    // 启动 HTTP API 服务
    go startAPIServer()
    // 启动代理服务器
    startProxyServer()
}

// startAPIServer 启动 HTTP 接口，接收配置更新并切换连接池
func startAPIServer() {
    http.HandleFunc(cfg.APIPasswordUpdate, func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost {
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
            return
        }
        var req struct {
            Hostname     string `json:"hostname"`
            Port         int    `json:"port"`
            Username     string `json:"username"`
            Password     string `json:"password"`
            DatabaseName string `json:"databasename"`
        }
        if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
            http.Error(w, "Bad request", http.StatusBadRequest)
            return
        }
        if req.Hostname == "" || req.Port == 0 || req.Username == "" || req.Password == "" || req.DatabaseName == "" {
            http.Error(w, "All fields required", http.StatusBadRequest)
            return
        }
        // 更新配置并 rotate
        connConfig.SetConfig(req.Hostname, req.Port, req.Username, req.Password, req.DatabaseName)
        rotatePools()
        w.WriteHeader(http.StatusOK)
        fmt.Fprint(w, "Config updated and rotated pools")
    })
    log.Printf("API server listening on %s", cfg.APIListenAddr)
    log.Fatal(http.ListenAndServe(cfg.APIListenAddr, nil))
}

// startProxyServer 开启 TCP 代理监听
func startProxyServer() {
    ln, err := net.Listen("tcp", cfg.ProxyListenAddr)
    if err != nil {
        log.Fatalf("Proxy listen failed: %v", err)
    }
    log.Printf("Proxy listening on %s", cfg.ProxyListenAddr)
    for {
        clientConn, err := ln.Accept()
        if err != nil {
            log.Printf("Accept error: %v", err)
            continue
        }
        go handleClient(clientConn)
    }
}

// handleClient 处理单个客户端连接，含 SSL/TLS, Startup, Auth 流程
func handleClient(clientConn net.Conn) {
    defer clientConn.Close()
    buf := bufio.NewReader(clientConn)

    // 检测 SSLRequest
    head, err := buf.Peek(8)
    if err == nil && binary.BigEndian.Uint32(head[:4]) == 8 && binary.BigEndian.Uint32(head[4:]) == 80877103 {
        buf.Discard(8)
        proxySSL(clientConn, buf, head)
        return
    }
    // 普通 Startup+Auth
    poolMu.Lock()
    p := activePool
    poolMu.Unlock()
    serverConn, err := p.Get()
    if err != nil {
        log.Printf("Get backend conn failed: %v", err)
        return
    }
    defer p.Put(serverConn)
    proxyStartupAuth(buf, clientConn, serverConn)
}

// proxySSL 中继 SSLRequest 并做 TLS 握手
func proxySSL(clientConn net.Conn, buf *bufio.Reader, head []byte) {
    poolMu.Lock()
    p := activePool
    poolMu.Unlock()
    serverConn, err := p.Get()
    if err != nil {
        log.Printf("Get backend conn failed: %v", err)
        return
    }
    defer p.Put(serverConn)

    serverConn.Write(head)
    reply := make([]byte, 1)
    io.ReadFull(serverConn, reply)
    clientConn.Write(reply)
    if reply[0] == 'S' {
        tlsCfg := &tls.Config{InsecureSkipVerify: true}
        clientConn = tls.Server(clientConn, tlsCfg)
        clientConn.(*tls.Conn).Handshake()
        serverConn = tls.Client(serverConn, tlsCfg)
        serverConn.(*tls.Conn).Handshake()
        buf = bufio.NewReader(clientConn)
    }
    proxyStartupAuth(buf, clientConn, serverConn)
}

// proxyStartupAuth 代理 StartupMessage 并完成认证
func proxyStartupAuth(buf *bufio.Reader, clientConn, serverConn net.Conn) {
    msg, err := readStartupMessage(buf)
    if err != nil {
        log.Printf("readStartupMessage error: %v", err)
        return
    }
    params := connConfig.GetConfig()
    msg.Parameters["user"] = params.Username
    msg.Parameters["database"] = params.Database
    data, _ := serializeStartup(msg)
    serverConn.Write(data)
    handleAuth(serverConn, clientConn, params.Username, params.Password)
    go io.Copy(serverConn, buf)
    io.Copy(clientConn, serverConn)
}

// readStartupMessage 读取并解析 StartupMessage
type StartupMessage struct {
    ProtocolVersion int32
    Parameters      map[string]string
    Raw             []byte
}
func readStartupMessage(r *bufio.Reader) (*StartupMessage, error) {
    header := make([]byte, 8)
    if _, err := io.ReadFull(r, header); err != nil {
        return nil, err
    }
    length := int32(binary.BigEndian.Uint32(header[:4]))
    if length < 8 {
        return nil, fmt.Errorf("invalid length: %d", length)
    }
    body := make([]byte, length-8)
    if _, err := io.ReadFull(r, body); err != nil {
        return nil, err
    }
    params, err := parseParameters(body[4:])
    if err != nil {
        return nil, err
    }
    version := int32(binary.BigEndian.Uint32(header[4:8]))
    return &StartupMessage{ProtocolVersion: version, Parameters: params, Raw: append(header, body...)}, nil
}

// parseParameters 解析 key=value 参数列表
func parseParameters(data []byte) (map[string]string, error) {
    m := make(map[string]string)
    i := 0
    for i < len(data) {
        j := bytes.IndexByte(data[i:], 0)
        if j < 0 { break }
        key := string(data[i : i+j])
        i += j + 1
        if key == "" { break }
        k := bytes.IndexByte(data[i:], 0)
        if k < 0 { break }
        val := string(data[i : i+k])
        i += k + 1
        m[key] = val
    }
    return m, nil
}

// serializeStartup 序列化 StartupMessage
type StartupMessage struct {
    ProtocolVersion int32
    Parameters      map[string]string
    Raw             []byte
}
func serializeStartup(msg *StartupMessage) ([]byte, error) {
    var buf bytes.Buffer
    buf.Write([]byte{0, 0, 0, 0})
    binary.Write(&buf, binary.BigEndian, uint32(msg.ProtocolVersion))
    for k, v := range msg.Parameters {
        buf.WriteString(k)
        buf.WriteByte(0)
        buf.WriteString(v)
        buf.WriteByte(0)
    }
    buf.WriteByte(0)
    total := int32(buf.Len())
    binary.BigEndian.PutUint32(buf.Bytes()[0:4], uint32(total))
    return buf.Bytes(), nil
}

// handleAuth 代理后端认证请求，支持 Cleartext、MD5、SCRAM-SHA-256
func handleAuth(serverConn, clientConn net.Conn, user, password string) error {
    for {
        var t [1]byte
        if _, err := io.ReadFull(serverConn, t[:]); err != nil {
            return err
        }
        var lenb [4]byte
        if _, err := io.ReadFull(serverConn, lenb[:]); err != nil {
            return err
        }
        length := binary.BigEndian.Uint32(lenb[:])
        payload := make([]byte, length-4)
        if length > 4 {
            if _, err := io.ReadFull(serverConn, payload); err != nil {
                return err
            }
        }
        if t[0] != 'R' {
            clientConn.Write(t[:]); clientConn.Write(lenb[:]); clientConn.Write(payload)
            continue
        }
        authType := binary.BigEndian.Uint32(payload[:4])
        switch authType {
        case 0:
            clientConn.Write(t[:]); clientConn.Write(lenb[:]); clientConn.Write(payload)
            return nil
        case 3:
            sendPasswordMsg(serverConn, password)
        case 5:
            salt := payload[4:8]
            sendPasswordMsg(serverConn, md5Password(password, user, salt))
        case 10:
            clientConn.Write(t[:]); clientConn.Write(lenb[:]); clientConn.Write(payload)
            return nil
        default:
            return fmt.Errorf("unsupported auth type %d", authType)
        }
    }
}

// sendPasswordMsg 构造并发送 PasswordMessage
func sendPasswordMsg(conn net.Conn, pwd string) error {
    data := []byte(pwd)
    length := int32(len(data) + 5)
    buf := new(bytes.Buffer)
    buf.WriteByte('p')
    binary.Write(buf, binary.BigEndian, length)
    buf.Write(data)
    buf.WriteByte(0)
    _, err := conn.Write(buf.Bytes())
    return err
}

// md5Password 生成 PostgreSQL MD5 密码散列
func md5Password(password, user string, salt []byte) string {
    h1 := md5.New()
    h1.Write([]byte(password + user))
    sum1 := h1.Sum(nil)
    h2 := md5.New()
    h2.Write(sum1)
    h2.Write(salt)
    return "md5" + hex.EncodeToString(h2.Sum(nil))
}
