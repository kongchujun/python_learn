package main

import (
    "bufio"
    "bytes"
    "crypto/md5"
    "crypto/tls"
    "encoding/binary"
    "encoding/hex"
    "encoding/json"
    "fmt"
    "io"
    "log"
    "net"
    "net/http"
    "sync"
)

// ConnectionConfig 存储 PostgreSQL 连接参数，支持并发安全读写
type ConnectionConfig struct {
    hostname     string
    port         int
    username     string
    password     string
    databaseName string
    mu           sync.RWMutex
}

// ConnParams 用于传递配置数据
type ConnParams struct {
    Hostname, Username, Password, Database string
    Port                                    int
}

// SetConfig 更新连接配置
func (cc *ConnectionConfig) SetConfig(hostname string, port int, username, password, databaseName string) {
    cc.mu.Lock()
    defer cc.mu.Unlock()
    cc.hostname = hostname
    cc.port = port
    cc.username = username
    cc.password = password
    cc.databaseName = databaseName
    log.Printf("Connection config updated: %s:%d user=%s db=%s", hostname, port, username, databaseName)
}

// GetConfig 返回当前连接参数
func (cc *ConnectionConfig) GetConfig() ConnParams {
    cc.mu.RLock()
    defer cc.mu.RUnlock()
    return ConnParams{Hostname: cc.hostname, Port: cc.port, Username: cc.username, Password: cc.password, Database: cc.databaseName}
}

// Config 定义代理和 API 服务地址及连接池参数
type Config struct {
    ProxyListenAddr   string // 代理监听地址
    APIListenAddr     string // API 监听地址
    APIPasswordUpdate string // 更新配置 API 路径
    PoolSize          int    // 连接池大小
    ProxyAuthPassword string // 代理访问校验密码
}

// StartupMessage 表示 PostgreSQL 启动包
type StartupMessage struct {
    ProtocolVersion int32
    Parameters      map[string]string
    Raw             []byte
}

// ConnPool 后端连接池，支持主动清空机制
type ConnPool struct {
    cc       *ConnectionConfig
    pool     chan net.Conn
    size     int
    draining bool
    mu       sync.Mutex
}

// newPool 创建连接池
func newPool(cc *ConnectionConfig, size int) *ConnPool {
    return &ConnPool{cc: cc, pool: make(chan net.Conn, size), size: size}
}

// Get 从池中获取连接，池空则新建
func (p *ConnPool) Get() (net.Conn, error) {
    select {
    case conn := <-p.pool:
        return conn, nil
    default:
        cfg := p.cc.GetConfig()
        return net.Dial("tcp", fmt.Sprintf("%s:%d", cfg.Hostname, cfg.Port))
    }
}

// Put 将连接归还池中，draining 时关闭
func (p *ConnPool) Put(conn net.Conn) {
    p.mu.Lock()
    defer p.mu.Unlock()
    if p.draining {
        conn.Close()
        return
    }
    select {
    case p.pool <- conn:
    default:
        conn.Close()
    }
}

// Reset 主动清空空闲连接，并重建 channel
func (p *ConnPool) Reset() {
    p.mu.Lock()
    defer p.mu.Unlock()
    p.draining = true
    close(p.pool)
    for c := range p.pool {
        c.Close()
    }
    p.pool = make(chan net.Conn, p.size)
    p.draining = false
}

// 全局变量：双池管理
var (
    connConfig = &ConnectionConfig{}
    cfg        = Config{
        ProxyListenAddr:   ":5433",
        APIListenAddr:     ":8080",
        APIPasswordUpdate: "/update-password",
        PoolSize:          10,
        ProxyAuthPassword: "pwd_postgres",
    }
    activePool *ConnPool
    oldPool    *ConnPool
    poolMu     sync.Mutex
)

// rotatePools 切换到新池并重置旧池
func rotatePools() {
    poolMu.Lock()
    defer poolMu.Unlock()
    newP := newPool(connConfig, cfg.PoolSize)
    if activePool != nil {
        oldPool = activePool
        oldPool.Reset()
    }
    activePool = newP
}

func main() {
    // 初始化配置与连接池
    connConfig.SetConfig("postgres", 5432, "postgres", "initial_password", "mydb")
    activePool = newPool(connConfig, cfg.PoolSize)

    go startAPIServer()
    startProxyServer()
}

// startAPIServer 提供 HTTP 接口，更新配置并切换池
func startAPIServer() {
    http.HandleFunc(cfg.APIPasswordUpdate, func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost {
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
            return
        }
        var req struct {
            Hostname     string `json:"hostname"`
            Port         int    `json:"port"`
            Username     string `json:"username"`
            Password     string `json:"password"`
            DatabaseName string `json:"databasename"`
        }
        if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
            http.Error(w, "Bad request", http.StatusBadRequest)
            return
        }
        if req.Hostname == "" || req.Port == 0 || req.Username == "" || req.Password == "" || req.DatabaseName == "" {
            http.Error(w, "All fields required", http.StatusBadRequest)
            return
        }
        connConfig.SetConfig(req.Hostname, req.Port, req.Username, req.Password, req.DatabaseName)
        rotatePools()
        w.WriteHeader(http.StatusOK)
        fmt.Fprint(w, "Config updated and pools rotated")
    })
    log.Printf("API listening on %s", cfg.APIListenAddr)
    log.Fatal(http.ListenAndServe(cfg.APIListenAddr, nil))
}

// startProxyServer 启动 TCP 代理
func startProxyServer() {
    ln, err := net.Listen("tcp", cfg.ProxyListenAddr)
    if err != nil {
        log.Fatalf("Proxy listen failed: %v", err)
    }
    log.Printf("Proxy listening on %s", cfg.ProxyListenAddr)
    for {
        clientConn, err := ln.Accept()
        if err != nil {
            log.Printf("Accept error: %v", err)
            continue
        }
        go handleClient(clientConn)
    }
}

// handleClient 处理客户端连接：SSL, Startup/Auth, 转发
func handleClient(clientConn net.Conn) {
    defer clientConn.Close()
    buf := bufio.NewReader(clientConn)

    // 先 Peek 看客户端是否发送了启动消息或 SSLRequest
    head, err := buf.Peek(8)
    if err != nil {
        log.Printf("Failed to peek startup/SSLRequest: %v", err)
        return
    }
    // 检测 SSLRequest

    head, err := buf.Peek(8)
    if err == nil && binary.BigEndian.Uint32(head[:4]) == 8 && binary.BigEndian.Uint32(head[4:]) == 80877103 {
        buf.Discard(8)
        proxySSL(clientConn, buf, head)
        return
    }

    poolMu.Lock()
    p := activePool
    poolMu.Unlock()
    serverConn, err := p.Get()
    if err != nil {
        log.Printf("Get backend conn failed: %v", err)
        return
    }
    defer p.Put(serverConn)
    proxyStartupAuth(buf, clientConn, serverConn)
}

// proxySSL 中继 SSLRequest 并执行 TLS 握手
func proxySSL(clientConn net.Conn, buf *bufio.Reader, head []byte) {
    poolMu.Lock()
    p := activePool
    poolMu.Unlock()
    serverConn, err := p.Get()
    if err != nil {
        log.Printf("Get backend conn failed: %v", err)
        return
    }
    defer p.Put(serverConn)

    serverConn.Write(head)
    reply := make([]byte, 1)
    io.ReadFull(serverConn, reply)
    clientConn.Write(reply)
    if reply[0] == 'S' {
        tlsCfg := &tls.Config{InsecureSkipVerify: true}
        clientConn = tls.Server(clientConn, tlsCfg)
        clientConn.(*tls.Conn).Handshake()
        serverConn = tls.Client(serverConn, tlsCfg)
        serverConn.(*tls.Conn).Handshake()
        buf = bufio.NewReader(clientConn)
    }
    proxyStartupAuth(buf, clientConn, serverConn)
}

// proxyStartupAuth 代理 StartupMessage，然后在 handleAuth 中进行密码校验并转发给后端
func proxyStartupAuth(buf *bufio.Reader, clientConn, serverConn net.Conn) {
    // 1. 读取并解析客户端 StartupMessage
    msg, err := readStartupMessage(buf)
    if err != nil {
        log.Printf("Startup read error: %v", err)
        return
    }
    // 2. 删除客户端可能带来的私有字段（如 proxy 参数），避免泄露给后端
    delete(msg.Parameters, "password")

    // 3. 替换为后端真实用户和数据库
    params := connConfig.GetConfig()
    msg.Parameters["user"] = params.Username
    msg.Parameters["database"] = params.Database

    // 4. 序列化并发送给后端
    data, _ := serializeStartup(msg)
    if _, err := serverConn.Write(data); err != nil {
        log.Printf("Failed to write startup to backend: %v", err)
        return
    }

    // 5. 在 handleAuth 里完成代理密码校验和后端认证流
    if err := handleAuth(serverConn, clientConn, params.Username, params.Password); err != nil {
        log.Printf("authentication error: %v", err)
        return
    }

    // 6. 双向转发剩余流量
    go io.Copy(serverConn, buf)
    io.Copy(clientConn, serverConn)
}
}

// readStartupMessage 解析 StartupMessage
func readStartupMessage(r *bufio.Reader) (*StartupMessage, error) {
    header := make([]byte, 8)
    if _, err := io.ReadFull(r, header); err != nil {
        return nil, err
    }
    length := int(binary.BigEndian.Uint32(header[:4]))
    body := make([]byte, length-8)
    if _, err := io.ReadFull(r, body); err != nil {
        return nil, err
    }
    params, _ := parseParameters(body[4:])
    version := int32(binary.BigEndian.Uint32(header[4:8]))
    return &StartupMessage{ProtocolVersion: version, Parameters: params, Raw: append(header, body...)}, nil
}

// parseParameters 解析 key=value 列表
func parseParameters(data []byte) (map[string]string, error) {
    m := make(map[string]string)
    i := 0
    for i < len(data) {
        j := bytes.IndexByte(data[i:], 0)
        if j < 0 { break }
        key := string(data[i : i+j])
        i += j + 1
        if key == "" { break }
        k := bytes.IndexByte(data[i:], 0)
        if k < 0 { break }
        val := string(data[i : i+k])
        i += k + 1
        m[key] = val
    }
    return m, nil
}

// serializeStartup 重建 StartupMessage
func serializeStartup(msg *StartupMessage) ([]byte, error) {
    var buf bytes.Buffer
    buf.Write([]byte{0, 0, 0, 0})
    binary.Write(&buf, binary.BigEndian, uint32(msg.ProtocolVersion))
    for k, v := range msg.Parameters {
        buf.WriteString(k); buf.WriteByte(0)
        buf.WriteString(v); buf.WriteByte(0)
    }
    buf.WriteByte(0)
    total := int32(buf.Len())
    binary.BigEndian.PutUint32(buf.Bytes()[0:4], uint32(total))
    return buf.Bytes(), nil
}

// handleAuth 代理后端认证，支持 Cleartext/MD5/SCRAM
func handleAuth(serverConn, clientConn net.Conn, user, dbPwd string) error {
    for {
        var t [1]byte
        if _, err := io.ReadFull(serverConn, t[:]); err != nil {
            return err
        }
        var lenb [4]byte
        if _, err := io.ReadFull(serverConn, lenb[:]); err != nil {
            return err
        }
        length := binary.BigEndian.Uint32(lenb[:])
        payload := make([]byte, length-4)
        if length > 4 {
            io.ReadFull(serverConn, payload)
        }
        if t[0] != 'R' {
            clientConn.Write(t[:]); clientConn.Write(lenb[:]); clientConn.Write(payload)
            continue
        }
        auth := binary.BigEndian.Uint32(payload[:4])
        switch auth {
        case 0:
            clientConn.Write(t[:]); clientConn.Write(lenb[:]); clientConn.Write(payload)
            return nil
        case 3:
            clientConn.Write(t[:]); clientConn.Write(lenb[:])
            var tag [1]byte; io.ReadFull(clientConn, tag[:])
            var plenb2 [4]byte; io.ReadFull(clientConn, plenb2[:])
            plen := binary.BigEndian.Uint32(plenb2[:]); pwdBytes := make([]byte, plen-4)
            io.ReadFull(clientConn, pwdBytes)
            proxyPwd := string(pwdBytes[:len(pwdBytes)-1])
            if proxyPwd != cfg.ProxyAuthPassword {
                return fmt.Errorf("proxy auth failed")
            }
            sendPasswordMsg(serverConn, dbPwd)
        case 5:
            clientConn.Write(t[:]); clientConn.Write(lenb[:]); clientConn.Write(payload)
            var tag [1]byte; io.ReadFull(clientConn, tag[:])
            var plenb2 [4]byte; io.ReadFull(clientConn, plenb2[:])
            plen := binary.BigEndian.Uint32(plenb2[:]); pwdBytes := make([]byte, plen-4)
            io.ReadFull(clientConn, pwdBytes)
            salt := payload[4:8]
            clientHash := string(pwdBytes[:len(pwdBytes)-1])
            expected := md5Password(cfg.ProxyAuthPassword, "", salt)
            if clientHash != expected {
                return fmt.Errorf("proxy auth md5 failed")
            }
            sendPasswordMsg(serverConn, md5Password(dbPwd, user, salt))
        case 10:
            clientConn.Write(t[:]); clientConn.Write(lenb[:]); clientConn.Write(payload)
            return nil
        default:
            return fmt.Errorf("unsupported auth %d", auth)
        }
    }
}

// sendPasswordMsg 构造并发送 PasswordMessage
func sendPasswordMsg(conn net.Conn, pwd string) error {
    data := []byte(pwd)
    length := int32(len(data) + 5)
    buf := new(bytes.Buffer)
    buf.WriteByte('p')
    binary.Write(buf, binary.BigEndian, length)
    buf.Write(data); buf.WriteByte(0)
    _, err := conn.Write(buf.Bytes())
    return err
}

// md5Password 生成 PostgreSQL MD5 密码散列
func md5Password(password, user string, salt []byte) string {
    h1 := md5.New(); h1.Write([]byte(password + user))
    sum1 := h1.Sum(nil)
    h2 := md5.New(); h2.Write(sum1); h2.Write(salt)
    return "md5" + hex.EncodeToString(h2.Sum(nil))
}
