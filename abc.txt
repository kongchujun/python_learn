package main

import (
    "bufio"
    "bytes"
    "crypto/md5"
    "crypto/tls"
    "encoding/binary"
    "encoding/hex"
    "encoding/json"
    "fmt"
    "io"
    "log"
    "net"
    "net/http"
    "sync"
)

// ConnectionConfig safely holds backend PostgreSQL connection parameters
type ConnectionConfig struct {
    hostname     string
    port         int
    username     string
    password     string
    databaseName string
    mu           sync.RWMutex
}

type ConnParams struct {
    Hostname, Username, Password, Database string
    Port                                    int
}

func (cc *ConnectionConfig) SetConfig(hostname string, port int, username, password, databaseName string) {
    cc.mu.Lock()
    defer cc.mu.Unlock()
    cc.hostname = hostname
    cc.port = port
    cc.username = username
    cc.password = password
    cc.databaseName = databaseName
    log.Printf("Config updated: %s:%d user=%s db=%s", hostname, port, username, databaseName)
}

func (cc *ConnectionConfig) GetConfig() ConnParams {
    cc.mu.RLock()
    defer cc.mu.RUnlock()
    return ConnParams{
        Hostname: cc.hostname,
        Port:     cc.port,
        Username: cc.username,
        Password: cc.password,
        Database: cc.databaseName,
    }
}

// Config holds proxy/API addresses, pool settings and TLS files
type Config struct {
    ProxyListenAddr   string
    APIListenAddr     string
    APIPasswordUpdate string
    PoolSize          int
    ProxyAuthPassword string
    TLSCertFile       string
    TLSKeyFile        string
}

// StartupMessage is a parsed PostgreSQL startup packet
type StartupMessage struct {
    ProtocolVersion int32
    Parameters      map[string]string
    Raw             []byte
}

// ConnPool manages backend TCP connections with reset capability
type ConnPool struct {
    cc       *ConnectionConfig
    pool     chan net.Conn
    size     int
    draining bool
    mu       sync.Mutex
}

func newPool(cc *ConnectionConfig, size int) *ConnPool {
    return &ConnPool{cc: cc, pool: make(chan net.Conn, size), size: size}
}

func (p *ConnPool) Get() (net.Conn, error) {
    select {
    case conn := <-p.pool:
        return conn, nil
    default:
        cfg := p.cc.GetConfig()
        return net.Dial("tcp", fmt.Sprintf("%s:%d", cfg.Hostname, cfg.Port))
    }
}

func (p *ConnPool) Put(conn net.Conn) {
    p.mu.Lock()
    defer p.mu.Unlock()
    if p.draining {
        conn.Close()
        return
    }
    select {
    case p.pool <- conn:
    default:
        conn.Close()
    }
}

func (p *ConnPool) Reset() {
    p.mu.Lock()
    defer p.mu.Unlock()
    p.draining = true
    close(p.pool)
    for c := range p.pool {
        c.Close()
    }
    p.pool = make(chan net.Conn, p.size)
    p.draining = false
}

var (
    connConfig = &ConnectionConfig{}
    cfg        = Config{
        ProxyListenAddr:   ":5433",
        APIListenAddr:     ":8080",
        APIPasswordUpdate: "/update-password",
        PoolSize:          10,
        ProxyAuthPassword: "pwd_postgres",
        TLSCertFile:       "server.crt",
        TLSKeyFile:        "server.key",
    }
    activePool *ConnPool
    oldPool    *ConnPool
    poolMu     sync.Mutex
    tlsConfig  *tls.Config
)

func rotatePools() {
    poolMu.Lock()
    defer poolMu.Unlock()
    newP := newPool(connConfig, cfg.PoolSize)
    if activePool != nil {
        oldPool = activePool
        oldPool.Reset()
    }
    activePool = newP
}

func main() {
    // load TLS certificate for SSL proxying
    cert, err := tls.LoadX509KeyPair(cfg.TLSCertFile, cfg.TLSKeyFile)
    if err != nil {
        log.Fatalf("Failed to load TLS certificate: %v", err)
    }
    tlsConfig = &tls.Config{Certificates: []tls.Certificate{cert}}

    // initial backend config
    connConfig.SetConfig("postgres", 5432, "postgres", "initial_password", "mydb")
    activePool = newPool(connConfig, cfg.PoolSize)

    go startAPIServer()
    startProxyServer()
}

func startAPIServer() {
    http.HandleFunc(cfg.APIPasswordUpdate, func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost {
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
            return
        }
        var req struct {
            Hostname     string `json:"hostname"`
            Port         int    `json:"port"`
            Username     string `json:"username"`
            Password     string `json:"password"`
            DatabaseName string `json:"databasename"`
        }
        if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
            http.Error(w, "Bad request", http.StatusBadRequest)
            return
        }
        if req.Hostname == "" || req.Port == 0 || req.Username == "" || req.Password == "" || req.DatabaseName == "" {
            http.Error(w, "All fields required", http.StatusBadRequest)
            return
        }
        connConfig.SetConfig(req.Hostname, req.Port, req.Username, req.Password, req.DatabaseName)
        rotatePools()
        w.WriteHeader(http.StatusOK)
        fmt.Fprint(w, "Config updated and pools rotated")
    })
    log.Printf("API listening on %s", cfg.APIListenAddr)
    log.Fatal(http.ListenAndServe(cfg.APIListenAddr, nil))
}

func startProxyServer() {
    ln, err := net.Listen("tcp", cfg.ProxyListenAddr)
    if err != nil {
        log.Fatalf("Proxy listen failed: %v", err)
    }
    log.Printf("Proxy listening on %s", cfg.ProxyListenAddr)
    for {
        clientConn, err := ln.Accept()
        if err != nil {
            log.Printf("Accept error: %v", err)
            continue
        }
        go handleClient(clientConn)
    }
}

func handleClient(clientConn net.Conn) {
    defer clientConn.Close()

    // get a backend connection from pool
    poolMu.Lock()
    p := activePool
    poolMu.Unlock()
    serverConn, err := p.Get()
    if err != nil {
        log.Printf("Get backend conn failed: %v", err)
        return
    }
    defer p.Put(serverConn)

    buf := bufio.NewReader(clientConn)

    // SSLRequest intercept
    header, err := buf.Peek(8)
    if err != nil {
        log.Printf("peek error: %v", err)
        return
    }
    length := binary.BigEndian.Uint32(header[0:4])
    proto := binary.BigEndian.Uint32(header[4:8])
    if length == 8 && proto == 80877103 {
        // consume SSLRequest
        buf.Discard(8)
        // forward to backend
        if _, err := serverConn.Write(header); err != nil {
            log.Printf("forward SSLRequest: %v", err)
            return
        }
        // read response ('S' or 'N')
        var resp [1]byte
        if _, err := io.ReadFull(serverConn, resp[:]); err != nil {
            log.Printf("read SSL response: %v", err)
            return
        }
        clientConn.Write(resp[:])

        if resp[0] == 'S' {
            // upgrade client connection to TLS
            clientTLS := tls.Server(clientConn, tlsConfig)
            if err := clientTLS.Handshake(); err != nil {
                log.Printf("client TLS handshake failed: %v", err)
                return
            }
            clientConn = clientTLS
            buf = bufio.NewReader(clientConn)

            // upgrade backend connection to TLS (skip verification)
            serverTLS := tls.Client(serverConn, &tls.Config{InsecureSkipVerify: true})
            if err := serverTLS.Handshake(); err != nil {
                log.Printf("backend TLS handshake failed: %v", err)
                return
            }
            serverConn = serverTLS
        }
    }

    // read and rewrite StartupMessage
    skb, err := readStartupMessage(buf)
    if err != nil {
        log.Printf("readStartupMessage error: %v", err)
        return
    }
    proxyPwd := skb.Parameters["password"]
    delete(skb.Parameters, "password")
    params := connConfig.GetConfig()
    skb.Parameters["user"] = params.Username
    skb.Parameters["database"] = params.Database
    data, err := serializeStartup(skb)
    if err != nil {
        log.Printf("serializeStartup error: %v", err)
        return
    }
    serverConn.Write(data)

    // authentication relay
    if err := handleAuth(serverConn, clientConn, params.Username, params.Password, proxyPwd); err != nil {
        log.Printf("authentication error: %v", err)
        return
    }

    // data proxying
    go io.Copy(serverConn, buf)
    io.Copy(clientConn, serverConn)
}

func handleAuth(serverConn, clientConn net.Conn, user, dbPwd, proxyPwd string) error {
    for {
        var t [1]byte
        if _, err := io.ReadFull(serverConn, t[:]); err != nil {
            return err
        }
        var lenb [4]byte
        if _, err := io.ReadFull(serverConn, lenb[:]); err != nil {
            return err
        }
        length := binary.BigEndian.Uint32(lenb[:])
        payload := make([]byte, length)
        if length > 0 {
            if _, err := io.ReadFull(serverConn, payload); err != nil {
                return err
            }
        }
        // relay to client
        clientConn.Write(t[:]); clientConn.Write(lenb[:]); clientConn.Write(payload)
        if t[0] != 'R' {
            continue
        }
        authType := binary.BigEndian.Uint32(payload[:4])
        switch authType {
        case 0:
            return nil
        case 3:
            // Cleartext
            if proxyPwd != cfg.ProxyAuthPassword {
                return fmt.Errorf("invalid proxy auth password")
            }
            // read client password message, then send backend password
            var tag [1]byte; io.ReadFull(clientConn, tag[:])
            var plenb2 [4]byte; io.ReadFull(clientConn, plenb2[:])
            plen := binary.BigEndian.Uint32(plenb2[:]); pwdBytes := make([]byte, plen-4)
            io.ReadFull(clientConn, pwdBytes)
            sendPasswordMsg(serverConn, dbPwd)
        case 5:
            // MD5
            salt := payload[4:8]
            sendPasswordMsg(serverConn, md5Password(dbPwd, user, salt))
        case 10:
            // SCRAM: just continue relaying until AuthenticationOk
            continue
        default:
            return fmt.Errorf("unsupported auth type %d", authType)
        }
    }
}

func sendPasswordMsg(conn net.Conn, pwd string) error {
    data := []byte(pwd)
    length := int32(len(data) + 5)
    buf := new(bytes.Buffer)
    buf.WriteByte('p')
    binary.Write(buf, binary.BigEndian, length)
    buf.Write(data); buf.WriteByte(0)
    _, err := conn.Write(buf.Bytes())
    return err
}

func readStartupMessage(r *bufio.Reader) (*StartupMessage, error) {
    header := make([]byte, 8)
    if _, err := io.ReadFull(r, header); err != nil {
        return nil, err
    }
    length := int(binary.BigEndian.Uint32(header[:4]))
    if length < 8 {
        return nil, fmt.Errorf("invalid startup message length: %d", length)
    }
    body := make([]byte, length-8)
    if _, err := io.ReadFull(r, body); err != nil {
        return nil, err
    }
    version := int32(binary.BigEndian.Uint32(header[4:8]))
    var params map[string]string
    if len(body) > 4 {
        params, _ = parseParameters(body[4:])
    } else {
        params = make(map[string]string)
    }
    return &StartupMessage{ProtocolVersion: version, Parameters: params, Raw: append(header, body...)}, nil
}

func parseParameters(data []byte) (map[string]string, error) {
    m := make(map[string]string)
    i := 0
    for i < len(data) {
        j := bytes.IndexByte(data[i:], 0)
        if j < 0 {
            break
        }
        key := string(data[i : i+j])
        i += j + 1
        if key == "" {
            break
        }
        k := bytes.IndexByte(data[i:], 0)
        if k < 0 {
            break
        }
        val := string(data[i : i+k])
        i += k + 1
        m[key] = val
    }
    return m, nil
}

func serializeStartup(msg *StartupMessage) ([]byte, error) {
    var buf bytes.Buffer
    buf.Write([]byte{0, 0, 0, 0})
    binary.Write(&buf, binary.BigEndian, uint32(msg.ProtocolVersion))
    for k, v := range msg.Parameters {
        buf.WriteString(k); buf.WriteByte(0)
        buf.WriteString(v); buf.WriteByte(0)
    }
    buf.WriteByte(0)
    total := int32(buf.Len())
    binary.BigEndian.PutUint32(buf.Bytes()[0:4], uint32(total))
    return buf.Bytes(), nil
}

func md5Password(password, user string, salt []byte) string {
    h1 := md5.New()
    h1.Write([]byte(password + user))
    sum1 := h1.Sum(nil)
    h2 := md5.New()
    h2.Write(sum1)
    h2.Write(salt)
    return "md5" + hex.EncodeToString(h2.Sum(nil))
}
