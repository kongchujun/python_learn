func handleAuth(serverConn, clientConn net.Conn, user, dbPwd, proxyPwd string) error {
    for {
        // read message type
        var t [1]byte
        if _, err := io.ReadFull(serverConn, t[:]); err != nil {
            return err
        }
        // read length
        var lenb [4]byte
        if _, err := io.ReadFull(serverConn, lenb[:]); err != nil {
            return err
        }
        length := binary.BigEndian.Uint32(lenb[:])
        // read payload (length includes 4 bytes of length)
        payload := make([]byte, 0)
        if length > 4 {
            payload = make([]byte, length-4)
            if _, err := io.ReadFull(serverConn, payload); err != nil {
                return err
            }
        }
        // relay full message to client
        clientConn.Write(t[:])
        clientConn.Write(lenb[:])
        if len(payload) > 0 {
            clientConn.Write(payload)
        }
        // if not Authentication (R), keep reading
        if t[0] != 'R' {
            continue
        }
        authType := binary.BigEndian.Uint32(payload[:4])
        switch authType {
        case 0:
            // AuthenticationOk
            return nil
        case 3:
            // Cleartext
            if proxyPwd != cfg.ProxyAuthPassword {
                return fmt.Errorf("invalid proxy auth password")
            }
            // read client's password message and forward only the needed response
            var tag [1]byte
            if _, err := io.ReadFull(clientConn, tag[:]); err != nil {
                return err
            }
            var plenb2 [4]byte
            if _, err := io.ReadFull(clientConn, plenb2[:]); err != nil {
                return err
            }
            plen := binary.BigEndian.Uint32(plenb2[:])
            pwdBytes := make([]byte, plen-4)
            if _, err := io.ReadFull(clientConn, pwdBytes); err != nil {
                return err
            }
            return sendPasswordMsg(serverConn, dbPwd)
        case 5:
            // MD5
            salt := payload[4:8]
            return sendPasswordMsg(serverConn, md5Password(dbPwd, user, salt))
        case 10:
            // SCRAM: continue relaying until AuthenticationOk
            continue
        default:
            return fmt.Errorf("unsupported auth type %d", authType)
        }
    }
}
