明白了！既然pgmaker会主动推送更新，那我们就去掉定时任务，只保留初始注册和被动接收更新的功能。这是修改后的配置：

## nginx.conf 配置

```nginx
# 需要确保nginx编译时包含以下模块：
# --with-http_lua_module
# --with-stream
# --with-stream_lua_module

events {
    worker_connections 1024;
}

http {
    # 共享字典，用于存储postgres连接信息
    lua_shared_dict pg_config 10m;
    
    # lua脚本路径
    lua_package_path "/etc/nginx/lua/?.lua;;";
    
    # 初始化脚本，nginx启动时执行
    init_by_lua_block {
        -- 全局变量
        pg_config_dict = ngx.shared.pg_config
    }
    
    # 工作进程启动后执行
    init_worker_by_lua_block {
        local function register_and_get_credentials()
            local http = require "resty.http"
            local httpc = http.new()
            local cjson = require "cjson"
            
            -- 准备注册数据，告诉pgmaker我们的回调地址
            local register_data = {
                callback_url = "http://your-nginx-server.com/credential-update"  -- 替换为实际的nginx地址
            }
            
            -- 向pgmaker注册并获取初始凭据
            local res, err = httpc:request_uri("http://pgmaker.com/credential", {
                method = "POST",  -- 注册通常用POST
                body = cjson.encode(register_data),
                headers = {
                    ["Content-Type"] = "application/json"
                },
                keepalive_timeout = 60,
                keepalive_pool = 10
            })
            
            if not res then
                ngx.log(ngx.ERR, "failed to register with pgmaker: ", err)
                return
            end
            
            if res.status ~= 200 then
                ngx.log(ngx.ERR, "pgmaker registration failed, status: ", res.status)
                return
            end
            
            -- 解析响应数据（假设返回JSON格式的postgres凭据）
            local ok, data = pcall(cjson.decode, res.body)
            
            if not ok then
                ngx.log(ngx.ERR, "failed to parse pgmaker response: ", data)
                return
            end
            
            -- 存储到共享字典
            pg_config_dict:set("host", data.host or "")
            pg_config_dict:set("port", data.port or "5432")
            pg_config_dict:set("user", data.user or "")
            pg_config_dict:set("password", data.pwd or "")
            pg_config_dict:set("database", data.database or "")
            
            ngx.log(ngx.INFO, "postgres config received from registration: ", res.body)
            
            -- 转发给应用
            local forward_res, forward_err = httpc:request_uri("http://myapp.com/api/secret", {
                method = "POST",
                body = res.body,
                headers = {
                    ["Content-Type"] = "application/json"
                },
                keepalive_timeout = 60,
                keepalive_pool = 10
            })
            
            if not forward_res then
                ngx.log(ngx.ERR, "failed to forward to myapp: ", forward_err)
                return
            end
            
            ngx.log(ngx.INFO, "initial credentials forwarded to myapp, status: ", forward_res.status)
        end
        
        -- nginx启动时执行注册
        register_and_get_credentials()
    }
    
    server {
        listen 80;
        
        # 健康检查端点
        location /health {
            access_log off;
            return 200 "OK";
        }
        
        # 接收pgmaker主动推送的凭据更新
        location /credential-update {
            lua_need_request_body on;
            
            content_by_lua_block {
                local cjson = require "cjson"
                
                -- 获取请求体
                local body = ngx.var.request_body
                if not body then
                    ngx.status = 400
                    ngx.say("Missing request body")
                    return
                end
                
                -- 解析JSON数据
                local ok, data = pcall(cjson.decode, body)
                if not ok then
                    ngx.status = 400
                    ngx.say("Invalid JSON format")
                    return
                end
                
                -- 更新共享字典
                pg_config_dict:set("host", data.host or "")
                pg_config_dict:set("port", data.port or "5432")
                pg_config_dict:set("user", data.user or "")
                pg_config_dict:set("password", data.pwd or "")
                pg_config_dict:set("database", data.database or "")
                
                ngx.log(ngx.INFO, "postgres config updated via push: ", body)
                
                -- 转发给应用
                local http = require "resty.http"
                local httpc = http.new()
                
                local res, err = httpc:request_uri("http://myapp.com/api/secret", {
                    method = "POST",
                    body = body,
                    headers = {
                        ["Content-Type"] = "application/json"
                    },
                    keepalive_timeout = 60,
                    keepalive_pool = 10
                })
                
                if not res then
                    ngx.log(ngx.ERR, "failed to forward to myapp: ", err)
                    ngx.status = 500
                    ngx.say("Failed to forward credentials")
                    return
                end
                
                ngx.status = 200
                ngx.say("Credentials updated and forwarded")
                ngx.log(ngx.INFO, "updated credentials forwarded to myapp, status: ", res.status)
            }
        }
    }
}

# Stream模块配置 - 用于代理postgres连接
stream {
    # 动态upstream配置
    upstream postgres_backend {
        server 127.0.0.1:5432 max_fails=1 fail_timeout=10s;
        balancer_by_lua_block {
            local balancer = require "ngx.balancer"
            
            -- 从http模块的共享字典获取配置
            local pg_config_dict = ngx.shared.pg_config
            local host = pg_config_dict:get("host")
            local port = pg_config_dict:get("port")
            
            if host and port then
                local ok, err = balancer.set_current_peer(host, tonumber(port))
                if not ok then
                    ngx.log(ngx.ERR, "failed to set current peer: ", err)
                    return ngx.exit(500)
                end
            else
                ngx.log(ngx.ERR, "postgres config not available")
                return ngx.exit(500)
            end
        }
    }
    
    server {
        listen 5432;
        proxy_pass postgres_backend;
        proxy_timeout 1s;
        proxy_responses 1;
        error_log /var/log/nginx/postgres_proxy_error.log;
    }
}
```

## 主要变化

1. **去掉了定时任务**：删除了每小时自动获取凭据的代码

2. **注册时提供回调地址**：在向`http://pgmaker.com/credential`注册时，告诉pgmaker我们的回调地址是`/credential-update`

3. **简化了流程**：
   - nginx启动时注册并获取初始凭据
   - pgmaker后续会主动推送更新到`/credential-update`端点
   - 每次收到更新都会转发给应用

## 配置说明

请记得修改以下内容：
- 将`http://your-nginx-server.com/credential-update`替换为实际的nginx服务器地址
- 根据pgmaker的实际API格式调整注册请求的数据结构

这样pgmaker就知道在需要更新凭据时应该调用哪个nginx的API了。
