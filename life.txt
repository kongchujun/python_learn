package main

import (
    "bufio"
    "bytes"
    "crypto/md5"
    "crypto/tls"
    "encoding/binary"
    "encoding/hex"
    "encoding/json"
    "fmt"
    "io"
    "log"
    "net"
    "net/http"
    "sync"
)

// ConnectionConfig 存储 PostgreSQL 连接参数
type ConnectionConfig struct {
    hostname     string
    port         int
    username     string
    password     string
    databaseName string
    mu           sync.RWMutex
}

// SetConfig 更新连接参数
func (cc *ConnectionConfig) SetConfig(hostname string, port int, username, password, databaseName string) {
    cc.mu.Lock()
    defer cc.mu.Unlock()
    cc.hostname = hostname
    cc.port = port
    cc.username = username
    cc.password = password
    cc.databaseName = databaseName
    log.Printf("Connection config updated: %s:%d user=%s db=%s", hostname, port, username, databaseName)
}

// GetConfig 返回当前连接配置
func (cc *ConnectionConfig) GetConfig() (string, int, string, string, string) {
    cc.mu.RLock()
    defer cc.mu.RUnlock()
    return cc.hostname, cc.port, cc.username, cc.password, cc.databaseName
}

// GetPostgresAddr 返回 host:port
func (cc *ConnectionConfig) GetPostgresAddr() string {
    host, port, _, _, _ := cc.GetConfig()
    return fmt.Sprintf("%s:%d", host, port)
}

// Config 定义代理和 API 服务地址
type Config struct {
    ProxyListenAddr   string // 代理监听地址，例如 ":5433"
    APIListenAddr     string // API 监听地址，例如 ":8080"
    APIPasswordUpdate string // 连接参数更新 API 路径，例如 "/update-password"
}

// StartupMessage 表示解析后的启动消息
type StartupMessage struct {
    ProtocolVersion int32
    Parameters      map[string]string
    Raw             []byte
}

func main() {
    cfg := Config{
        ProxyListenAddr:   ":5433",
        APIListenAddr:     ":8080",
        APIPasswordUpdate: "/update-password",
    }
    cc := &ConnectionConfig{
        hostname:     "postgres",
        port:         5432,
        username:     "postgres",
        password:     "initial_password",
        databaseName: "mydb",
    }

    // 启动 API 服务和代理服务
    go startAPIServer(cfg, cc)
    startProxyServer(cfg, cc)
}

// startAPIServer 启动 HTTP API 服务
func startAPIServer(cfg Config, cc *ConnectionConfig) {
    http.HandleFunc(cfg.APIPasswordUpdate, func(w http.ResponseWriter, r *http.Request) {
        if r.Method != http.MethodPost {
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
            return
        }
        var req struct {
            Hostname     string `json:"hostname"`
            Port         int    `json:"port"`
            Username     string `json:"username"`
            Password     string `json:"password"`
            DatabaseName string `json:"databasename"`
        }
        if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
            http.Error(w, "Invalid request body", http.StatusBadRequest)
            return
        }
        if req.Hostname == "" || req.Port <= 0 || req.Username == "" || req.Password == "" || req.DatabaseName == "" {
            http.Error(w, "All fields are required", http.StatusBadRequest)
            return
        }
        cc.SetConfig(req.Hostname, req.Port, req.Username, req.Password, req.DatabaseName)
        w.WriteHeader(http.StatusOK)
        fmt.Fprint(w, "Connection config updated")
    })
    log.Printf("API server listening on %s", cfg.APIListenAddr)
    if err := http.ListenAndServe(cfg.APIListenAddr, nil); err != nil {
        log.Fatalf("API server failed: %v", err)
    }
}

// startProxyServer 启动代理服务
func startProxyServer(cfg Config, cc *ConnectionConfig) {
    listener, err := net.Listen("tcp", cfg.ProxyListenAddr)
    if err != nil {
        log.Fatalf("Proxy listen error: %v", err)
    }
    log.Printf("Proxy server listening on %s", cfg.ProxyListenAddr)
    for {
        clientConn, err := listener.Accept()
        if err != nil {
            log.Printf("Accept error: %v", err)
            continue
        }
        go handleClientConnection(clientConn, cc)
    }
}

// handleClientConnection 处理客户端连接，支持 SSLRequest
func handleClientConnection(clientConn net.Conn, cc *ConnectionConfig) {
    defer clientConn.Close()
    clientBuf := bufio.NewReader(clientConn)

    // 检测并代理 SSLRequest
    head, err := clientBuf.Peek(8)
    if err == nil && binary.BigEndian.Uint32(head[0:4]) == 8 && binary.BigEndian.Uint32(head[4:8]) == 80877103 {
        clientBuf.Discard(8)
        proxySSL(clientConn, clientBuf, cc, head)
        return
    }

    // 普通启动和认证代理
    postgresAddr := cc.GetPostgresAddr()
    serverConn, err := net.Dial("tcp", postgresAddr)
    if err != nil {
        log.Printf("dial postgres failed: %v", err)
        return
    }
    defer serverConn.Close()
    proxyStartupAndAuth(clientBuf, clientConn, serverConn, cc)
}

// proxySSL 中继 SSLRequest 并做 TLS 握手
func proxySSL(clientConn net.Conn, clientBuf *bufio.Reader, cc *ConnectionConfig, head []byte) {
    postgresAddr := cc.GetPostgresAddr()
    serverConn, err := net.Dial("tcp", postgresAddr)
    if err != nil {
        log.Printf("dial postgres failed: %v", err)
        return
    }
    defer serverConn.Close()

    // 转发 SSLRequest 包
    if _, err := serverConn.Write(head); err != nil {
        log.Printf("forward SSLRequest failed: %v", err)
        return
    }

    // 读取后端回复并回写给客户端
    reply := make([]byte, 1)
    if _, err := io.ReadFull(serverConn, reply); err != nil {
        log.Printf("read SSL reply failed: %v", err)
        return
    }
    if _, err := clientConn.Write(reply); err != nil {
        log.Printf("write SSL reply to client failed: %v", err)
        return
    }

    // 如果支持 SSL，则升级至 TLS
    if reply[0] == 'S' {
        tlsCfg := &tls.Config{InsecureSkipVerify: true}
        clientConn = tls.Server(clientConn, tlsCfg)
        if err := clientConn.(*tls.Conn).Handshake(); err != nil {
            log.Printf("client TLS handshake failed: %v", err)
            return
        }
        serverConn = tls.Client(serverConn, tlsCfg)
        if err := serverConn.(*tls.Conn).Handshake(); err != nil {
            log.Printf("server TLS handshake failed: %v", err)
            return
        }
        clientBuf = bufio.NewReader(clientConn)
    }

    proxyStartupAndAuth(clientBuf, clientConn, serverConn, cc)
}

// proxyStartupAndAuth 代理 StartupMessage 并处理认证
func proxyStartupAndAuth(clientBuf *bufio.Reader, clientConn, serverConn net.Conn, cc *ConnectionConfig) {
    startupMsg, err := readStartupMessage(clientBuf)
    if err != nil {
        log.Printf("readStartupMessage error: %v", err)
        return
    }
    _, _, user, pass, db := cc.GetConfig()
    startupMsg.Parameters["user"] = user
    startupMsg.Parameters["database"] = db
    modified, err := serializeStartup(startupMsg)
    if err != nil {
        log.Printf("serializeStartup error: %v", err)
        return
    }
    if _, err := serverConn.Write(modified); err != nil {
        log.Printf("write startup to postgres failed: %v", err)
        return
    }
    if err := handleAuth(serverConn, clientConn, user, pass); err != nil {
        log.Printf("authentication proxy error: %v", err)
        return
    }
    go io.Copy(serverConn, clientBuf)
    io.Copy(clientConn, serverConn)
}

// handleAuth 中继认证，支持 Cleartext, MD5, SCRAM-SHA-256
func handleAuth(serverConn, clientConn net.Conn, user, password string) error {
    for {
        // 读取后端认证请求或其他消息
        var t [1]byte
        if _, err := io.ReadFull(serverConn, t[:]); err != nil {
            return err
        }
        var lenb [4]byte
        if _, err := io.ReadFull(serverConn, lenb[:]); err != nil {
            return err
        }
        length := binary.BigEndian.Uint32(lenb[:])
        payload := make([]byte, length-4)
        if length > 4 {
            if _, err := io.ReadFull(serverConn, payload); err != nil {
                return err
            }
        }
        if t[0] != 'R' {
            clientConn.Write(t[:]); clientConn.Write(lenb[:]); clientConn.Write(payload)
            continue
        }
        authType := binary.BigEndian.Uint32(payload[:4])
        switch authType {
        case 0: // AuthenticationOk
            clientConn.Write(t[:]); clientConn.Write(lenb[:]); clientConn.Write(payload)
            return nil
        case 3: // Cleartext
            sendPasswordMsg(serverConn, password)
        case 5: // MD5
            salt := payload[4:8]
            sendPasswordMsg(serverConn, md5Password(password, user, salt))
        case 10: // SCRAM-SHA-256，交由客户端处理
            clientConn.Write(t[:]); clientConn.Write(lenb[:]); clientConn.Write(payload)
            return nil
        default:
            return fmt.Errorf("unsupported auth type %d", authType)
        }
    }
}

// sendPasswordMsg 构造并发送 PasswordMessage
func sendPasswordMsg(conn net.Conn, pwd string) error {
    data := []byte(pwd)
    length := int32(len(data) + 5)
    buf := new(bytes.Buffer)
    buf.WriteByte('p')
    binary.Write(buf, binary.BigEndian, length)
    buf.Write(data)
    buf.WriteByte(0)
    _, err := conn.Write(buf.Bytes())
    return err
}

// md5Password 生成 PostgreSQL MD5 密码散列
func md5Password(password, user string, salt []byte) string {
    h1 := md5.New()
    h1.Write([]byte(password + user))
    sum1 := h1.Sum(nil)
    h2 := md5.New()
    h2.Write(sum1)
    h2.Write(salt)
    return "md5" + hex.EncodeToString(h2.Sum(nil))
}

// serializeStartup 序列化 StartupMessage
func serializeStartup(msg *StartupMessage) ([]byte, error) {
    var buf bytes.Buffer
    buf.Write([]byte{0, 0, 0, 0})
    binary.Write(&buf, binary.BigEndian, uint32(msg.ProtocolVersion))
    for k, v := range msg.Parameters {
        buf.WriteString(k); buf.WriteByte(0)
        buf.WriteString(v); buf.WriteByte(0)
    }
    buf.WriteByte(0)
    total := int32(buf.Len())
    binary.BigEndian.PutUint32(buf.Bytes()[0:4], uint32(total))
    return buf.Bytes(), nil
}

// readStartupMessage 读取并解析 StartupMessage
func readStartupMessage(r *bufio.Reader) (*StartupMessage, error) {
    header := make([]byte, 8)
    if _, err := io.ReadFull(r, header); err != nil {
        return nil, err
    }
    length := int32(binary.BigEndian.Uint32(header[0:4]))
    if length < 8 {
        return nil, fmt.Errorf("invalid length: %d", length)
    }
    body := make([]byte, length-8)
    if _, err := io.ReadFull(r, body); err != nil {
        return nil, err
    }
    params, err := parseParameters(body[4:])
    if err != nil {
        return nil, err
    }
    version := int32(binary.BigEndian.Uint32(header[4:8]))
    return &StartupMessage{ProtocolVersion: version, Parameters: params, Raw: append(header, body...)}, nil
}

// parseParameters 解析参数列表
func parseParameters(data []byte) (map[string]string, error) {
    m := make(map[string]string)
    i := 0
    for i < len(data) {
        j := bytes.IndexByte(data[i:], 0)
        if j < 0 { break }
        key := string(data[i : i+j])
        i += j+1
        if key == "" { break }
        k := bytes.IndexByte(data[i:], 0)
        if k < 0 { break }
        val := string(data[i : i+k])
        i += k+1
        m[key] = val
    }
    return m, nil
}
