#!/usr/bin/env python3
import ast
import argparse
import shutil
from pathlib import Path

TARGET_IMPORT_MODULE = "marimo._server.api.middleware"
MIDDLEWARE_CLASS = "AuthMiddleware"
TARGET_FUNC = "create_starlette_app"

class Patcher(ast.NodeTransformer):
    def __init__(self):
        super().__init__()
        self.import_patched = False
        self.extend_patched = False

    # 1) 处理: from marimo._server.api.middleware import (...) 里加入 AuthMiddleware
    def visit_ImportFrom(self, node: ast.ImportFrom):
        self.generic_visit(node)
        if node.module == TARGET_IMPORT_MODULE:
            # names 是 alias 列表
            imported = {alias.name for alias in node.names}
            if MIDDLEWARE_CLASS not in imported:
                node.names.append(ast.alias(name=MIDDLEWARE_CLASS, asname=None))
                self.import_patched = True
        return node

    # 2) 处理函数 create_starlette_app 内 if enable_auth: 中的 final_middlewares.extend([...])
    def visit_FunctionDef(self, node: ast.FunctionDef):
        if node.name != TARGET_FUNC:
            return self.generic_visit(node)

        # 在函数体里找: if enable_auth: ... 最外层一级即可（与你给的代码结构匹配）
        for stmt in node.body:
            if isinstance(stmt, ast.If) and self._is_enable_auth_test(stmt.test):
                self._patch_enable_auth_block(stmt)
                break
        return node

    @staticmethod
    def _is_enable_auth_test(test: ast.expr) -> bool:
        # 兼容几种写法：if enable_auth: / if bool(enable_auth): / if enable_auth is True:
        if isinstance(test, ast.Name) and test.id == "enable_auth":
            return True
        if isinstance(test, ast.Call) and isinstance(test.func, ast.Name) and test.func.id == "bool":
            return any(isinstance(a, ast.Name) and a.id == "enable_auth" for a in test.args)
        if isinstance(test, ast.Compare):
            # enable_auth is True / == True
            left_is_enable = isinstance(test.left, ast.Name) and test.left.id == "enable_auth"
            return left_is_enable
        return False

    def _patch_enable_auth_block(self, if_node: ast.If):
        """
        在 if enable_auth: 块中，找到:
            final_middlewares.extend([...])
        的列表参数，若未包含 Middleware(AuthMiddleware)，则插入在
        Middleware(CustomSessionMiddleware, ...) 之后；如未找到该锚点，则 append 到列表末尾。
        """
        # 遍历 If 体，找到形如 final_middlewares.extend([ ... ]) 的调用
        extend_calls = []
        for inner in if_node.body:
            # 可能是 Expr(Call(...))
            call = None
            if isinstance(inner, ast.Expr) and isinstance(inner.value, ast.Call):
                call = inner.value
            elif isinstance(inner, ast.Assign) and isinstance(inner.value, ast.Call):
                call = inner.value

            if call and self._is_final_middlewares_extend(call):
                # 第一个匹配就够了（与你给的代码结构一致）
                extend_calls.append(call)

        if not extend_calls:
            return  # 没找到就不处理

        call = extend_calls[0]
        if not call.args or not isinstance(call.args[0], ast.List):
            return  # 不是我们预期的列表参数形态，放弃

        list_arg: ast.List = call.args[0]

        # 幂等：若已经有 Middleware(AuthMiddleware)，则跳过
        if any(self._is_mw_authmiddleware(elt) for elt in list_arg.elts):
            self.extend_patched = True
            return

        new_node = self._make_middleware_auth_call()

        # 尝试插到 CustomSessionMiddleware 后面
        idx_after_css = self._find_index_after_customsession(list_arg.elts)
        if idx_after_css is not None:
            list_arg.elts.insert(idx_after_css + 1, new_node)
        else:
            list_arg.elts.append(new_node)

        self.extend_patched = True

    @staticmethod
    def _is_final_middlewares_extend(call: ast.Call) -> bool:
        # 识别 final_middlewares.extend(...)
        func = call.func
        return (
            isinstance(func, ast.Attribute)
            and func.attr == "extend"
            and isinstance(func.value, ast.Name)
            and func.value.id == "final_middlewares"
        )

    @staticmethod
    def _is_middleware_call(node: ast.AST, first_arg_name: str | None = None) -> bool:
        # 识别 Middleware(...)
        if not isinstance(node, ast.Call):
            return False
        if not isinstance(node.func, ast.Name) or node.func.id != "Middleware":
            return False
        if first_arg_name is None:
            return True
        # 检查第一个位置参数是否为指定名字（如 CustomSessionMiddleware / AuthMiddleware）
        return bool(
            node.args
            and isinstance(node.args[0], ast.Name)
            and node.args[0].id == first_arg_name
        )

    def _is_mw_authmiddleware(self, node: ast.AST) -> bool:
        return self._is_middleware_call(node, MIDDLEWARE_CLASS)

    def _find_index_after_customsession(self, elts: list[ast.AST]) -> int | None:
        for i, elt in enumerate(elts):
            if self._is_middleware_call(elt, "CustomSessionMiddleware"):
                return i
        return None

    @staticmethod
    def _make_middleware_auth_call() -> ast.Call:
        # 生成：Middleware(AuthMiddleware)
        return ast.Call(
            func=ast.Name(id="Middleware", ctx=ast.Load()),
            args=[ast.Name(id=MIDDLEWARE_CLASS, ctx=ast.Load())],
            keywords=[],
        )


def main():
    ap = argparse.ArgumentParser(description="AST patch: add AuthMiddleware import and usage.")
    ap.add_argument("file", help="Target python file to patch in-place.")
    ap.add_argument("--no-backup", action="store_true", help="Do not create .bak backup")
    args = ap.parse_args()

    path = Path(args.file)
    src = path.read_text(encoding="utf-8")

    tree = ast.parse(src)
    patcher = Patcher()
    tree = patcher.visit(tree)
    ast.fix_missing_locations(tree)

    try:
        new_src = ast.unparse(tree)  # Python 3.9+
    except AttributeError:
        raise SystemExit("需要 Python 3.9+（支持 ast.unparse）。")

    if not args.no_backup:
        shutil.copy2(path, path.with_suffix(path.suffix + ".bak"))

    path.write_text(new_src, encoding="utf-8")

    print(f"[ok] 写回 {path}")
    print(f" - import 修改: {'是' if patcher.import_patched else '（可能已存在）否'}")
    print(f" - enable_auth 插入: {'是' if patcher.extend_patched else '（可能已存在）否'}")

if __name__ == "__main__":
    main()
